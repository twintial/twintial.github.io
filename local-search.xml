<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java编程思想</title>
    <link href="undefined2020/03/10/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    <url>2020/03/10/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-对象导论"><a href="#第一章-对象导论" class="headerlink" title="第一章 对象导论"></a>第一章 对象导论</h1><h3 id="访问控制的原因"><a href="#访问控制的原因" class="headerlink" title="访问控制的原因"></a>访问控制的原因</h3><ol><li>为了让客户端程序员无法触及他们不应该触及的部分</li><li>允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员</li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>区分前期绑定和后期绑定</p><h3 id="范性出现的原因"><a href="#范性出现的原因" class="headerlink" title="范性出现的原因"></a>范性出现的原因</h3><p>​        java SE5之前容器中只能存储Object对象，即当对象从容器中取出时需要向下转型为程序员需要的类型，然而除非知道所要处理的对象类型，这种转换是不安全的。<strong>向下转型和运行时的检查需要额为的程序运行时间，也需要程序员付出更多的心血。</strong></p><h3 id="对象创建的生命周期"><a href="#对象创建的生命周期" class="headerlink" title="对象创建的生命周期"></a>对象创建的生命周期</h3><ol><li>在编写程序的时候确定对象的存储空间和生命周期。可以通过将对象置于栈中（有时被称为automatic variable或scoped variable）或静态存储区域来实现。</li><li>在被称为堆的内存池中动态地创建对象。</li></ol><h1 id="第二章-对象"><a href="#第二章-对象" class="headerlink" title="第二章 对象"></a>第二章 对象</h1><h3 id="程序运行时，对象可以存在的位置"><a href="#程序运行时，对象可以存在的位置" class="headerlink" title="程序运行时，对象可以存在的位置"></a>程序运行时，对象可以存在的位置</h3><ol><li>寄存器</li><li>栈</li><li>堆：通用的对象池，用于存放所有的java对象。</li><li>常量存储</li><li>非RAM存储</li></ol><h3 id="高精度数字"><a href="#高精度数字" class="headerlink" title="高精度数字"></a>高精度数字</h3><p>BigInteget和BigDecimal</p><h3 id="获取系统信息"><a href="#获取系统信息" class="headerlink" title="获取系统信息"></a>获取系统信息</h3><pre><code class="java">System.getProperties().list(System.out);System.out.println(System.getProperty(&quot;user.name&quot;));System.out.println(System.getProperty(&quot;java.library.path&quot;));</code></pre><h1 id="第五章-初始化与清理"><a href="#第五章-初始化与清理" class="headerlink" title="第五章 初始化与清理"></a>第五章 初始化与清理</h1><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><ol><li>方法名相同而参数列表不同。</li><li>基本类型的参数重载，如果没有找到char，char会提升至int。</li><li>返回值不能用来区分重载方法。</li></ol><p>###什么时候需要使用finalize()</p><ol><li>当在java类中调用非java代码时，如c/c++，需要在finalize()中释放其占据的内存。一般情况下不需要使用finalize()</li><li>用于对象<strong>终结条件</strong>的验证，用于发现错误，之后也需要去除（使用<code>System.gc()</code>可以强制进行垃圾回收）</li></ol><h3 id="垃圾回收器的工作原理"><a href="#垃圾回收器的工作原理" class="headerlink" title="垃圾回收器的工作原理"></a>垃圾回收器的工作原理</h3><p>​    java采用<strong>自适应</strong>的垃圾回收机制（见Java编程思想第四版P89）</p><h3 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h3><p>​    基本类型作为局部变量必须被初始化，而作为成员变量，会获得自己默认的初始值。对象类型的初始值为null。</p><h3 id="类的初始化过程"><a href="#类的初始化过程" class="headerlink" title="类的初始化过程"></a>类的初始化过程</h3><ol><li>因为构造器为静态函数，因此首次创建此类或者类的静态方法/静态域首次被访问时，Java解释器必须找到类路径，以定位xxx.class文件。</li><li>然后载入Dog.class，有关静态初始化的所有动作都会被执行，且只执行这一次。</li><li>当用new xxx()创建对象的时候，首先将在堆上为对象分配足够的存储空间。</li><li>将这块存储空间清0，这是所有的基本类型成员被设置成了默认值，对象成员被设置成了null。</li><li>执行所有字段定义处的初始化动作。</li><li>执行构造器。（将涉及很多动作，尤其是涉及继承的时候）</li></ol><h1 id="第七章-复用类"><a href="#第七章-复用类" class="headerlink" title="第七章 复用类"></a>第七章 复用类</h1><h3 id="final关键词"><a href="#final关键词" class="headerlink" title="final关键词"></a>final关键词</h3><ol><li><strong>数据</strong>：final通常用于基本类型变量。若用于对象类型则表示此应用不能改变，而引用指向的对象的值依然可以改变，因此没有太大意义。</li><li><strong>方法</strong>：明确禁止覆写。</li><li><strong>类</strong>：明确禁止继承。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习中遇到的问题</title>
    <link href="undefined2019/10/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>2019/10/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Logistic-regression"><a href="#Logistic-regression" class="headerlink" title="Logistic regression"></a>Logistic regression</h1><p><strong>常用的数据集预处理方法</strong></p><ul><li>找出数据集的维度和形状（m_train, m_test, num_px,….）</li><li>用reshape方法将数据集的每一个样本化为一个列向量（num_px * numpx * 3, 1）</li><li>标准化数据（n/(MAX - MIN)）</li></ul><p><strong>注意</strong></p><p>图片处理的scipy.imread和imresize已经被抛弃，用matplotlib.pyplot.imread或者PLT.Image.open代替imread。用Image对象image.resize代替imresize</p><p><strong>reshape的坑</strong></p><pre><code class="python">train_x_flatten = train_x_orig.reshape(-1, train_x_orig.shape[0])train_x_flatten2 = train_x_orig.reshape(train_x_orig.shape[0], -1).T</code></pre><p>两者不相等，要了解其中含义</p><p>#He initialization</p><p>​    This function is similar to the previous initialize_parameters_random(…). The only difference is that instead of multiplying np.random.randn(..,..) by 10, you will multiply it by <strong>sqrt(2./layers_dims[l-1])</strong> , which is what He initialization recommends for layers with a ReLU activation.</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在用Maven搭建SpringMVC项目时出现的问题</title>
    <link href="undefined2019/10/13/%E5%9C%A8%E7%94%A8Maven%E6%90%AD%E5%BB%BASpringMVC%E9%A1%B9%E7%9B%AE%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>2019/10/13/%E5%9C%A8%E7%94%A8Maven%E6%90%AD%E5%BB%BASpringMVC%E9%A1%B9%E7%9B%AE%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>IDE: IntelliJ IDEA 2019.2.3专业版<br>系统：MacOS<br>JDK：1.8</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Maven项目没有src文件夹"><a href="#Maven项目没有src文件夹" class="headerlink" title="Maven项目没有src文件夹"></a>Maven项目没有src文件夹</h2><p>打开Perference设置，在Build, Execution, Deployment-&gt;Build Tools-&gt;Maven-&gt;Runner的VM Options中添加<strong>-DarchetypeCatalog=internal</strong></p><h2 id="项目Add-Framework-Support中无法添加SpringMVC框架"><a href="#项目Add-Framework-Support中无法添加SpringMVC框架" class="headerlink" title="项目Add Framework Support中无法添加SpringMVC框架"></a>项目Add Framework Support中无法添加SpringMVC框架</h2><ul><li>先在Project Structure的Modules中删除Spring框架，重新添加SpringMVC框架</li><li>如果还是没有，打开Perference设置，在Plugins中勾选启用SpringMVC</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回顾UML</title>
    <link href="undefined2019/10/10/%E5%9B%9E%E9%A1%BEUML/"/>
    <url>2019/10/10/%E5%9B%9E%E9%A1%BEUML/</url>
    
    <content type="html"><![CDATA[<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><img src="https://i.natfrp.com/9fdfaefc97ad92394e08125d4ae04fae.png" srcset="/img/loading.gif" alt="class" style="zoom:50%;"><h2 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h2><ol><li><p><strong>Inheritance|继承</strong>：字面意义</p><pre><code class="c++">class CMyDoc : public CDocument{    private:      CObList myList;};</code></pre><img src="https://i.natfrp.com/40270b82a208cdb66a47d376cf7105d9.png" srcset="/img/loading.gif" alt="inheritance" style="zoom:50%;"></li><li><p><strong>Composition|组成</strong>：一个类包含另一个类，部分和整体的生命周期一致。分为composition by value和composition by reference。（下例为composition by value）</p><pre><code class="c++">class CMyDoc : public CDocument{    private:        CObList myList;};</code></pre><img src="https://i.natfrp.com/5bebb222646084471eb19e9f1f0bb289.png" srcset="/img/loading.gif" alt="composition" style="zoom:50%;"></li><li><p><strong>Aggregation|聚合</strong>：composition的一种，即composition by reference。比composition by value的关系弱。以指针的形式表现，是一种弱的拥有关系。可以在需要的时候为指针分配空间，不需要的时候释放。部分与整体生命周期不一致。</p><pre><code>class CMyDoc : public CDocument{    private:        CObList* myList;};</code></pre><p><img src="https://i.natfrp.com/4964eaacdd9614b0dc0bcde4f91f437b.png" srcset="/img/loading.gif" alt="aggregation"></p></li><li><p><strong>Association|关联</strong>：一个类必须知道另一个类的成员和变量。若A-&gt;B，则A中存在classB的实例。关联包括聚合和组成。有双向和单项两种。</p><p><img src="https://i.natfrp.com/95e8b899324878203d7337860a187de6.png" srcset="/img/loading.gif" alt="img"></p></li></ol><p>（待续）</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="undefined2019/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>2019/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h1><ul><li><p><strong>定义</strong><br>首先定义一个算法骨干，推迟其中一些步骤使它们在<strong>子类</strong>中获得定义。即这些步骤在父亲类中是抽象的，需要在子类中实现。Template Method使得子类可以重新定义算法中的某些步骤，而不需要改变算法的架构（骨干）。<br>我们平时使用的许多接口都采用了这种方法。</p></li><li><p><strong>类图表示</strong></p><p><img src="/img/backup/TemplateMethod.png" srcset="/img/loading.gif" alt="TemplateMethod"></p></li><li><p><strong>示例</strong></p><ul><li><p>类图：</p><img src="https://i.natfrp.com/8057cae3fc6aeaed54a45e8a787338c8.png" srcset="/img/loading.gif" alt="TemplateMethodSample" style="zoom:50%;"></li><li><p>java代码：</p><pre><code class="java">public class Main {    public static void main(String[] args) {        Generalization algorithm = new Realization();        algorithm.findSolution();    }}abstract class Generalization{    // 定义一个算法骨干    public void findSolution(){        stepOne();        stepTwo();        stepThr();        stepFor();    }    protected void stepOne(){        System.out.println(&quot;Generalization: stepOne&quot;);    }    // 存在两个为实现的步骤，将在子类中实现    abstract protected void stepTwo();    abstract protected void stepThr();    protected void stepFor(){        System.out.println(&quot;Generalization: stepFor&quot;);    }}abstract class Specialization extends Generalization{    // 实现了算法的stepThr，stepThr中也存在抽象方法，因此stepThr也算作一个算法骨干    @Override    protected void stepThr(){        step3_1();        step3_2();        step3_3();    }    protected void step3_1(){        System.out.println(&quot;Specialization: step3_1&quot;);    }    // stepThr的step3_2将在子类中实现    abstract protected void step3_2();    protected void step3_3(){        System.out.println(&quot;Specialization: step3_2&quot;);    }}class Realization extends Specialization{    @Override    protected void stepTwo() {        System.out.println(&quot;Realization: stepTwo&quot;);    }    @Override    protected void step3_2() {        System.out.println(&quot;Realization: step3_2&quot;);    }    @Override    protected void stepFor() {        super.stepFor();        System.out.println(&quot;Realization: stepFor&quot;);    }}</code></pre></li><li><p>输出:</p><pre>Generalization: stepOneRealization: stepTwoSpecialization: step3_1Realization: step3_2Specialization: step3_2Generalization: stepForRealization: stepFor</pre></li></ul></li></ul><h1 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h1><ul><li><p><strong>定义</strong></p><p>首先定义一个族系算法（a family of algorithms），然后封装其中每一个算法成为类class，使得它们可以被交换使用。</p><p>Strategy可以使算法添加，删除不影响客户。</p></li><li><p><strong>类图表示</strong></p><p><img src="/img/backup/Strategy.png" srcset="/img/loading.gif" alt="Strategy"></p></li><li><p><strong>示例</strong></p><ul><li><p>类图</p><p><img src="https://i.natfrp.com/bbc90d5c49dcd2906e03115bc815c536.png" srcset="/img/loading.gif" alt="StrategySample"></p></li><li><p>c++代码</p><p>首先定义一个族系的父类Strategy，在这个例子中算法家族做的是定义一个文本格式。format()函数是一个Template Method，其中的步骤justify()需要子类实现。</p><p><strong>由于Strategy需要实现算法抽换。因此，可以看出Strategy这一设计模式大多数情况下都需要用到Template Method，抽换对象是最后实现所有步骤的子类，而这样的子类将会有很多个，每一个都实现了不同的功能。</strong></p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstring&gt;using namespace std;class Strategy{public:    Strategy(int width):_width(width){}    void format(){        char line[80], word[30];        ifstream inFile(&quot;text.txt&quot;, ios::in);        line[0] = &#39;\0&#39;;        inFile &gt;&gt; word;        strcat(line, word);        while (inFile &gt;&gt; word){            if (strlen(line) + strlen(word) + 1 &gt; _width) {                justufy(line);            }            else{                strcat(line, &quot; &quot;);            }            strcat(line, word);        }        justufy(line);    }protected:    int _width;private:    virtual void justufy(char* line) = 0;};</code></pre><p>LeftStrategy为家族中的一员，实现左对齐。</p><pre><code class="c++">class LeftStragety: public Strategy{public:    LeftStragety(int width): Strategy(width){}private:    void justify(char *line) override{        cout &lt;&lt; line &lt;&lt; endl;        line[0] = &#39;\0&#39;;    }};</code></pre><p>RightStrategy为家族中的一员，实现右对齐。</p><pre><code class="c++">class RightStragety: public Strategy{public:    RightStragety(int width): Strategy(width){}private:    void justify(char *line) override{        char buf[80];        int offset = _width - strlen(line);        memset(buf, &#39; &#39;, 80);        strcpy(&amp;(buf[offset]), line);        cout &lt;&lt; buf &lt;&lt; endl;        line[0] = &#39;\0&#39;;    }};</code></pre><p>CenterStrategy为家族中的一员，实现居中。</p><pre><code class="c++">class CenterStragety: public Strategy{public:    CenterStragety(int width): Strategy(width){}private:    void justify(char *line) override{        char buf[80];        int offset = (_width - strlen(line)) / 2;        memset(buf, &#39; &#39;, 80);        strcpy(&amp;(buf[offset]), line);        cout &lt;&lt; buf &lt;&lt; endl;        line[0] = &#39;\0&#39;;    }};</code></pre><p>以上是整个族系算法。接下来还需要一个类实现算法抽换和执行。</p><p>setStrategy()实现抽换，doit()执行。</p><p>(也可以不构造此类，让用户自己进行算法的抽换)</p><pre><code class="c++">class Test{public:    enum StrategyType{        Undefined, Left, Right, Center    };    Test(): _strategy(NULL){}    void setStrategy(int type, int width){        if (_strategy != NULL) {            delete _strategy;        }        switch (type) {            case Left:                _strategy = new LeftStragety(width);                break;            case Right:                _strategy = new RightStragety(width);                    break;            case Center:                _strategy = new CenterStragety(width);                    break;            default:                break;        }    }    void doit(){        _strategy-&gt;format();    }private:Strategy* _strategy;    int a;};</code></pre><p>main()函数</p><pre><code class="c++">int main(int argc, const char * argv[]) {    Test _test;    int type, width;    cout &lt;&lt; &quot;Exit(0) Left(1) Right(2) Center(3): &quot;;    cin &gt;&gt; type;    while (type) {        cout &lt;&lt; &quot;width: &quot;;        cin &gt;&gt; width;        _test.setStrategy(type, width);        _test.doit();        cout &lt;&lt; &quot;Exit(0) Left(1) Right(2) Center(3): &quot;;        cin &gt;&gt; type;    }}</code></pre><p>若之后要加入在家族中加入一个新成员（这里指新的格式），只要在Test类的setStrategy（抽换算法）中添加一个新的选择即可。</p></li></ul></li></ul><h1 id="Observer-publish-subscribe"><a href="#Observer-publish-subscribe" class="headerlink" title="Observer/publish-subscribe"></a>Observer/publish-subscribe</h1><ul><li><p><strong>定义</strong></p><p>在objects之间定义“一对多”的依存关系，当一个object发生改变时，其他依存于它的objects们也会被通知并更新。</p></li><li><p><strong>类图表示</strong></p><p>java标准库：<br><img src="/img/backup/Observer.png" srcset="/img/loading.gif" alt="Observer"></p></li><li><p><strong>示例</strong></p><ul><li><p>类图</p><p><img src="https://i.natfrp.com/6cafc22f5ae227f56111092958fdae27.png" srcset="/img/loading.gif" alt="ObserverSample"></p></li><li><p>java代码</p><p><strong>java中已经封装了Observer和Observable以供使用，这里为了进一步掌握这个设计模式，重新实现了Observer设计模式。</strong></p><p>首先定一个Observe接口和Subject主体用于通知全部订阅了的观察者（对应标准库中的Observable）</p><pre><code class="java">interface Observer{    void update(int value);}class Subject{    int m_value;    List&lt;Observer&gt; m_views;    Subject(){        m_views = new ArrayList&lt;&gt;();    }    public void addObserver(Observer observe){        m_views.add(observe);    }    private void notifyChanges(){        for (Observer observe: m_views){            observe.update(m_value);        }    }    public void set_value(int value){        m_value = value;        notifyChanges();    }}</code></pre><p>实现了继承Observer的两个观察者</p><pre><code class="java">class DivObserve implements Observer{    private int m_div;    DivObserve(int div){        m_div = div;    }    @Override    public void update(int value) {        System.out.println(value+&quot; div &quot;+m_div+&quot; = &quot;+(value / m_div));    }}class ModObserve implements Observer{    private int m_mod;    ModObserve(int mod){        m_mod = mod;    }    @Override    public void update(int value) {        System.out.println(value+&quot; mod &quot;+m_mod+&quot; = &quot;+(value % m_mod));    }}</code></pre><p>main()函数在创建新观察者后，调用addObserver()函数订阅（依赖）subject主体。</p><pre><code class="java">public class Main {    public static void main(String[] args) {        Subject subject = new Subject();        DivObserve div1 = new DivObserve(4);        DivObserve div2 = new DivObserve(3);        ModObserve mod1 = new ModObserve(3);        subject.addObserver(div1);        subject.addObserver(div2);        subject.addObserver(mod1);        subject.set_value(14);    }}</code></pre></li><li><p>输出</p><pre>14 div 4 = 314 div 3 = 414 mod 3 = 2</pre></li></ul></li></ul><h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><ul><li><p><strong>定义</strong></p><p>提供一种方法可以循环访问一个聚合物（List，Vector等）而无需显露聚合物的底部表述。</p><p>比如java中遍历不同的聚合物需要知道不同聚合物获得元素的方法。</p></li><li><p><strong>类图表示</strong></p><p><img src="/img/backup/Iteration.png" srcset="/img/loading.gif" alt="Iteration"><br>java标准库：<br><img src="/img/backup/Iteration1.png" srcset="/img/loading.gif" alt="Iteration1"></p></li><li><p><strong>为什么要用Iteration来遍历</strong></p><ul><li><p>Iteration可以提供一种统一的方法访问一个聚合物，客户无需知道聚合物的具体用法。</p><p><code>for(Iterator it = aggregation.iterater(); it.hasNext(); )</code></p><p> <code>{ ... }</code></p></li><li><p>用Iteration在改变聚合物的种类时，可以减少对代码的修改（无需修改循环部分），符合OCP的设计准则。</p></li></ul></li></ul><h1 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h1><ul><li><p><strong>定义</strong></p><p>单例模式，确保某个class只能生成唯一一个实体。使用private修饰的构造函数实现。</p></li><li><p><strong>类图表示</strong></p><p>Singleton的实现方法有很多种，这里只介绍比较实用的一种。<br><img src="/img/backup/Singleton.png" srcset="/img/loading.gif" alt="Singleton"></p></li><li><p><strong>示例</strong></p><ul><li><p>java代码</p><pre><code class="java">public class SingleObject {   //创建 SingleObject 的一个对象   private static SingleObject instance = new SingleObject();   //让构造函数为 private，这样该类就不会被实例化   private SingleObject(){}   //获取唯一可用的对象   public static SingleObject getInstance(){      return instance;   }   public void showMessage(){      System.out.println(&quot;Hello World!&quot;);   }}</code></pre></li></ul></li></ul><h1 id="FlyWeight"><a href="#FlyWeight" class="headerlink" title="FlyWeight"></a>FlyWeight</h1><p>参考：<a href="https://sourcemaking.com/design_patterns" target="_blank" rel="noopener">Design Patterns</a></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回顾html</title>
    <link href="undefined2019/10/08/%E5%9B%9E%E9%A1%BEhtml/"/>
    <url>2019/10/08/%E5%9B%9E%E9%A1%BEhtml/</url>
    
    <content type="html"><![CDATA[<p>对html语言进行了回顾和再次学习。</p><h2 id="html样式"><a href="#html样式" class="headerlink" title="html样式"></a>html样式</h2><p>一些标签和属性都用html中的style属性所代替了。</p><h4 id="被抛弃的标签和属性"><a href="#被抛弃的标签和属性" class="headerlink" title="被抛弃的标签和属性"></a>被抛弃的标签和属性</h4><table><thead><tr><th>标签/属性</th><th>描述</th></tr></thead><tbody><tr><td>&lt;center&gt;</td><td>定义居中的内容</td></tr><tr><td>&lt;font&gt;和&lt;basefont&gt;</td><td>定义HTML字体</td></tr><tr><td>&lt;s&gt;和&lt;strike&gt;(使用&lt;del&gt;代替)</td><td>定义删除线文本</td></tr><tr><td>&lt;u&gt;(使用样式&lt;ins&gt;代替)</td><td>定义下划线文本</td></tr><tr><td>align</td><td>定义文本对齐方式</td></tr><tr><td>bgcolor/color</td><td>定义背景/文本颜色</td></tr></tbody></table><h2 id="html折行"><a href="#html折行" class="headerlink" title="html折行"></a>html折行</h2><p>使用&lt;br /&gt;标签:</p><pre><code class="html">&lt;p&gt;This is&lt;br /&gt;a para&lt;br /&gt;graph with line breaks&lt;/p&gt;</code></pre><h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><table><thead><tr><th>标签</th><th>效果</th></tr></thead><tbody><tr><td>&lt;p&gt;</td><td>正常</td></tr><tr><td>&lt;big&gt;</td><td><big>大号</big></td></tr><tr><td>&lt;em&gt;</td><td><em>着重</em></td></tr><tr><td>&lt;i&gt;</td><td><i>斜体</i></td></tr><tr><td>&lt;small&gt;</td><td><small>小号</small></td></tr><tr><td>&lt;b&gt;</td><td><b>粗体</b></td></tr><tr><td>&lt;strong&gt;</td><td><strong>加强语气</strong></td></tr><tr><td>&lt;sub&gt;</td><td>正常<sub>下标</sub></td></tr><tr><td>&lt;sup&gt;</td><td>正常<sup>上标</sup></td></tr><tr><td>&lt;ins&gt;</td><td><ins>插入</ins></td></tr><tr><td>&lt;del&gt;</td><td><del>删除</del></td></tr></tbody></table><h4 id="“计算机输出“标签"><a href="#“计算机输出“标签" class="headerlink" title="“计算机输出“标签"></a>“计算机输出“标签</h4><table><thead><tr><th>标签</th><th>效果</th></tr></thead><tbody><tr><td>&lt;code&gt;</td><td><code>prinf()</code></td></tr><tr><td>&lt;kbd&gt;</td><td><kbd>space</kbd></td></tr><tr><td>&lt;pre&gt;</td><td><pre>预格式文本</pre></td></tr><tr><td>&lt;var&gt;</td><td><var>变量</var></td></tr><tr><td>&lt;tt&gt;</td><td><tt>打字机格式</tt></td></tr></tbody></table><p>&lt;code&gt; 元素不保留多余的空格和折行，用&lt;pre&gt;解决。</p><pre><code>&lt;code&gt;&lt;pre&gt;var person = {    firstName:&quot;Bill&quot;,    lastName:&quot;Gates&quot;,    age:50,    eyeColor:&quot;blue&quot;}&lt;/pre&gt;&lt;/code&gt;</code></pre><p>效果：</p><code><pre>var person = {    firstName:"Bill",    lastName:"Gates",    age:50,    eyeColor:"blue"}</pre></code><h4 id="引用和术语定义"><a href="#引用和术语定义" class="headerlink" title="引用和术语定义"></a>引用和术语定义</h4><table><thead><tr><th>标签</th><th>效果</th></tr></thead><tbody><tr><td>&lt;abbr&gt;(缩写)</td><td><abbr title="etcetera">etc.</abbr></td></tr><tr><td>&lt;acronym&gt;(首字母缩写)</td><td><acronym title="World Wide Web">WWW</acronym></td></tr><tr><td>&lt;q&gt;</td><td><q>引用，周围有引号</q></td></tr><tr><td>&lt;bdo&gt;(dir=”rtl”)</td><td><bdo dir="rtl">Reverse</bdo></td></tr><tr><td>&lt;dfn&gt;</td><td><p><dfn title="World Health Organization">WHO</dfn> 成立于 1948 年。</p></td></tr></tbody></table><h2 id="HTML-链接-target-属性"><a href="#HTML-链接-target-属性" class="headerlink" title="HTML 链接 - target 属性"></a>HTML 链接 - target 属性</h2><p>下面的这行会在新窗口打开文档：</p><pre><code>&lt;a href=&quot;http://www.w3school.com.cn/&quot; target=&quot;_blank&quot;&gt;Visit W3School!&lt;/a&gt;</code></pre><h2 id="HTML-链接-name-属性"><a href="#HTML-链接-name-属性" class="headerlink" title="HTML 链接 - name 属性"></a>HTML 链接 - name 属性</h2><p>首先，我们在 HTML 文档中对锚进行命名（创建一个书签）：</p><pre><code>&lt;a name=&quot;tips&quot;&gt;基本的注意事项 - 有用的提示&lt;/a&gt;</code></pre><p>然后，我们在同一个文档中创建指向该锚的链接：</p><pre><code>&lt;a href=&quot;#tips&quot;&gt;有用的提示&lt;/a&gt;</code></pre><p>您也可以在其他页面中创建指向该锚的链接：</p><pre><code>&lt;a href=&quot;http://www.w3school.com.cn/html/html_links.asp#tips&quot;&gt;有用的提示&lt;/a&gt;</code></pre><h2 id="div与span的区别"><a href="#div与span的区别" class="headerlink" title="div与span的区别"></a>div与span的区别</h2><p>div是块级元素，可以用于布局。<br>span是内联元素，多用于为部分文本设置不一样的样式。</p><h2 id="HTML文件路径"><a href="#HTML文件路径" class="headerlink" title="HTML文件路径"></a>HTML文件路径</h2><table><thead><tr><th align="left">路径</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">&lt;img src=”picture.jpg”&gt;</td><td align="left">picture.jpg 位于与当前网页相同的文件夹</td></tr><tr><td align="left">&lt;img src=”images/picture.jpg”&gt;</td><td align="left">picture.jpg 位于当前文件夹的 images 文件夹中</td></tr><tr><td align="left">&lt;img src=”/images/picture.jpg”&gt;</td><td align="left">picture.jpg 当前站点根目录的 images 文件夹中</td></tr><tr><td align="left">&lt;img src=”../picture.jpg”&gt;</td><td align="left">picture.jpg 位于当前文件夹的上一级文件夹中</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>