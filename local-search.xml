<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring事务@transaction</title>
    <link href="undefined2020/03/30/Spring%E4%BA%8B%E5%8A%A1-transaction/"/>
    <url>2020/03/30/Spring%E4%BA%8B%E5%8A%A1-transaction/</url>
    
    <content type="html"><![CDATA[<p><strong>转载自<a href="https://mp.weixin.qq.com/s/enKOM3F_Xxg123HPMCFUPw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/enKOM3F_Xxg123HPMCFUPw</a></strong></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务管理在系统开发中是不可缺少的一部分，<code>Spring</code>提供了很好事务管理机制，主要分为<code>编程式事务</code>和<code>声明式事务</code>两种。</p><p><strong>编程式事务</strong>：是指在代码中手动的管理事务的提交、回滚等操作，代码侵入性比较强，如下示例：</p><pre><code class="java">try {    //TODO something     transactionManager.commit(status);} catch (Exception e) {    transactionManager.rollback(status);    throw new InvoiceApplyException(&quot;异常失败&quot;);}</code></pre><p><strong>声明式事务</strong>：基于<code>AOP</code>面向切面的，它将具体业务与事务处理部分解耦，代码侵入性很低，所以在实际开发中声明式事务用的比较多。声明式事务也有两种实现方式，一是基于<code>TX</code>和<code>AOP</code>的xml配置文件方式，二种就是基于@Transactional注解了。</p><pre><code class="java">@Transactional@GetMapping(&quot;/test&quot;)public String test() {    int insert = cityInfoDictMapper.insert(cityInfoDict);}</code></pre><p>#@Transactional介绍</p><h4 id="1、-Transactional注解可以作用于哪些地方？"><a href="#1、-Transactional注解可以作用于哪些地方？" class="headerlink" title="1、@Transactional注解可以作用于哪些地方？"></a>1、@Transactional注解可以作用于哪些地方？</h4><p>@Transactional 可以作用在<code>接口</code>、<code>类</code>、<code>类方法</code>。</p><ul><li><strong>作用于类</strong>：当把@Transactional 注解放在类上时，表示所有该类的<code>public</code>方法都配置相同的事务属性信息。</li><li><strong>作用于方法</strong>：当类配置了@Transactional，方法也配置了@Transactional，方法的事务会覆盖类的事务配置信息。</li><li><strong>作用于接口</strong>：不推荐这种使用方法，因为一旦标注在Interface上并且配置了Spring AOP 使用CGLib动态代理，将会导致@Transactional注解失效</li></ul><pre><code class="java"> @Transactional @RestController @RequestMapping public class MybatisPlusController {     @Autowired     private CityInfoDictMapper cityInfoDictMapper;     @Transactional(rollbackFor = Exception.class)     @GetMapping(&quot;/test&quot;)     public String test() throws Exception {         CityInfoDict cityInfoDict = new CityInfoDict();         cityInfoDict.setParentCityId(2);         cityInfoDict.setCityName(&quot;2&quot;);         cityInfoDict.setCityLevel(&quot;2&quot;);         cityInfoDict.setCityCode(&quot;2&quot;);         int insert = cityInfoDictMapper.insert(cityInfoDict);         return insert + &quot;&quot;;    }}</code></pre><h4 id="2、-Transactional注有哪些属性？"><a href="#2、-Transactional注有哪些属性？" class="headerlink" title="2、@Transactional注有哪些属性？"></a>2、@Transactional注有哪些属性？</h4><h5 id="propagation属性"><a href="#propagation属性" class="headerlink" title="propagation属性"></a>propagation属性</h5><p><code>propagation</code> 代表事务的传播行为，默认值为 <code>Propagation.REQUIRED</code>，其他的属性信息如下：</p><ul><li><code>Propagation.REQUIRED</code>：如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。<strong>(</strong> 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 <strong>）</strong></li><li><code>Propagation.SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</li><li><code>Propagation.MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</li><li><code>Propagation.REQUIRES_NEW</code>：重新创建一个新的事务，如果当前存在事务，暂停当前的事务。<strong>(</strong> 当类A中的 a 方法用默认<code>Propagation.REQUIRED</code>模式，类B中的 b方法加上采用 <code>Propagation.REQUIRES_NEW</code>模式，然后在 a 方法中调用 b方法操作数据库，然而 a方法抛出异常后，b方法并没有进行回滚，因为<code>Propagation.REQUIRES_NEW</code>会暂停 a方法的事务 <strong>)</strong></li><li><code>Propagation.NOT_SUPPORTED</code>：以非事务的方式运行，如果当前存在事务，暂停当前的事务。</li><li><code>Propagation.NEVER</code>：以非事务的方式运行，如果当前存在事务，则抛出异常。</li><li><code>Propagation.NESTED</code> ：和 Propagation.REQUIRED 效果一样。</li></ul><h5 id="isolation-属性"><a href="#isolation-属性" class="headerlink" title="isolation 属性"></a>isolation 属性</h5><p><code>isolation</code> ：事务的隔离级别，默认值为 <code>Isolation.DEFAULT</code>。</p><ul><li>Isolation.DEFAULT：使用底层数据库默认的隔离级别。</li><li>Isolation.READ_UNCOMMITTED</li><li>Isolation.READ_COMMITTED</li><li>Isolation.REPEATABLE_READ</li><li>Isolation.SERIALIZABLE</li></ul><h5 id="timeout-属性"><a href="#timeout-属性" class="headerlink" title="timeout 属性"></a>timeout 属性</h5><p><code>timeout</code> ：事务的超时时间，默认值为 -1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</p><h5 id="readOnly-属性"><a href="#readOnly-属性" class="headerlink" title="readOnly 属性"></a>readOnly 属性</h5><p><code>readOnly</code> ：指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</p><h5 id="rollbackFor-属性"><a href="#rollbackFor-属性" class="headerlink" title="rollbackFor 属性"></a>rollbackFor 属性</h5><p><code>rollbackFor</code> ：用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。</p><h5 id="noRollbackFor属性"><a href="#noRollbackFor属性" class="headerlink" title="noRollbackFor属性"></a><strong>noRollbackFor</strong>属性</h5><p><code>noRollbackFor</code>：抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。</p><p>#@Transactional失效场景</p><p>接下来我们结合具体的代码分析一下哪些场景下，@Transactional 注解会失效。</p><h4 id="1、-Transactional-应用在非-public-修饰的方法上"><a href="#1、-Transactional-应用在非-public-修饰的方法上" class="headerlink" title="1、@Transactional 应用在非 public 修饰的方法上"></a>1、@Transactional 应用在非 public 修饰的方法上</h4><p>如果<code>Transactional</code>注解应用在非<code>public</code> 修饰的方法上，Transactional将会失效。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aOhsEJ0TtJSM5kcSOKZGJDOJoUPF0IHL2wvUHIzlHVYOib6bEN2tKkCyUn8fOxMVicBxvoKpgXU2HDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>之所以会失效是因为在Spring AOP 代理时，如上图所示 <code>TransactionInterceptor</code> （事务拦截器）在目标方法执行前后进行拦截，<code>DynamicAdvisedInterceptor</code>（CglibAopProxy 的内部类）的 intercept 方法或 <code>JdkDynamicAopProxy</code> 的 invoke 方法会间接调用 <code>AbstractFallbackTransactionAttributeSource</code>的 <code>computeTransactionAttribute</code> 方法，获取Transactional 注解的事务配置信息。</p><pre><code class="java">protected TransactionAttribute computeTransactionAttribute(Method method,    Class&lt;?&gt; targetClass) {        // Don&#39;t allow no-public methods as required.        if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {        return null;}</code></pre><p>此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。</p><p><strong>注意：<code>protected</code>、<code>private</code> 修饰的方法上使用 <code>@Transactional</code> 注解，虽然事务无效，但不会有任何报错，这是我们很容犯错的一点。</strong></p><h4 id="2、-Transactional-注解属性-propagation-设置错误"><a href="#2、-Transactional-注解属性-propagation-设置错误" class="headerlink" title="2、@Transactional 注解属性 propagation 设置错误"></a>2、@Transactional 注解属性 propagation 设置错误</h4><p>这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。</p><p><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。<br><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。<br><code>TransactionDefinition.PROPAGATION_NEVER</code>：以非事务方式运行，如果当前存在事务，则抛出异常。</p><h4 id="3、-Transactional-注解属性-rollbackFor-设置错误"><a href="#3、-Transactional-注解属性-rollbackFor-设置错误" class="headerlink" title="3、@Transactional 注解属性 rollbackFor 设置错误"></a>3、@Transactional 注解属性 rollbackFor 设置错误</h4><p><code>rollbackFor</code> 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查<code>unchecked</code>异常（继承自 <code>RuntimeException</code>的异常）或者 <code>Error</code>才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定 <strong>rollbackFor</strong>属性。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aOhsEJ0TtJSM5kcSOKZGJDOENdU9CHkPlMgJrCv3Du00eDAiaaqleo6D9Q49dQuwY4lddQOsRRiadPA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="java">// 希望自定义的异常可以进行回滚@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class</code></pre><p>若在目标方法中抛出的异常是 <code>rollbackFor</code> 指定的异常的子类，事务同样会回滚。Spring源码如下：</p><pre><code class="java"> private int getDepth(Class&lt;?&gt; exceptionClass, int depth) {         if (exceptionClass.getName().contains(this.exceptionName)) {             // Found it!             return depth; }         // If we&#39;ve gone as far as we can go and haven&#39;t found it...         if (exceptionClass == Throwable.class) {             return -1; } return getDepth(exceptionClass.getSuperclass(), depth + 1);}</code></pre><h4 id="4、同一个类中方法调用，导致-Transactional失效"><a href="#4、同一个类中方法调用，导致-Transactional失效" class="headerlink" title="4、同一个类中方法调用，导致@Transactional失效"></a>4、同一个类中方法调用，导致@Transactional失效</h4><p>开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。</p><p>那为啥会出现这种情况？其实这还是由于使用<code>Spring AOP</code>代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由<code>Spring</code>生成的代理对象来管理。</p><pre><code class="java">//@Transactional     @GetMapping(&quot;/test&quot;)     private Integer A() throws Exception {         CityInfoDict cityInfoDict = new CityInfoDict();         cityInfoDict.setCityName(&quot;2&quot;);         /**          * B 插入字段为 3的数据          */         this.insertB();         /**          * A 插入字段为 2的数据          */         int insert = cityInfoDictMapper.insert(cityInfoDict);         return insert;     }     @Transactional()     public Integer insertB() throws Exception {         CityInfoDict cityInfoDict = new CityInfoDict();         cityInfoDict.setCityName(&quot;3&quot;);         cityInfoDict.setParentCityId(3);         return cityInfoDictMapper.insert(cityInfoDict);     }</code></pre><h4 id="5、异常被你的-catch“吃了”导致-Transactional失效"><a href="#5、异常被你的-catch“吃了”导致-Transactional失效" class="headerlink" title="5、异常被你的 catch“吃了”导致@Transactional失效"></a>5、异常被你的 catch“吃了”导致@Transactional失效</h4><p>这种情况是最常见的一种@Transactional注解失效场景</p><pre><code class="java">    @Transactional    private Integer A() throws Exception {        int insert = 0;        try {            CityInfoDict cityInfoDict = new CityInfoDict();            cityInfoDict.setCityName(&quot;2&quot;);            cityInfoDict.setParentCityId(2);            /**             * A 插入字段为 2的数据             */            insert = cityInfoDictMapper.insert(cityInfoDict);            /**             * B 插入字段为 3的数据             */            b.insertB();        } catch (Exception e) {            e.printStackTrace();        }    }</code></pre><p>如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务还能正常回滚吗？</p><p>答案：不能！</p><p>会抛出异常：</p><pre><code class="java">1org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</code></pre><p>因为当<code>ServiceB</code>中抛出了一个异常以后，<code>ServiceB</code>标识当前事务需要<code>rollback</code>。但是<code>ServiceA</code>中由于你手动的捕获这个异常并进行处理，<code>ServiceA</code>认为当前事务应该正常<code>commit</code>。此时就出现了前后不一致，也就是因为这样，抛出了前面的<code>UnexpectedRollbackException</code>异常。</p><p><code>spring</code>的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行<code>commit</code> or <code>rollback</code>，事务是否执行取决于是否抛出<code>runtime异常</code>。如果抛出<code>runtime exception</code> 并在你的业务方法中没有catch到的话，事务会回滚。</p><p>在业务方法中一般不需要catch异常，如果非要catch一定要抛出<code>throw new RuntimeException()</code>，或者注解中指定抛异常类型<code>@Transactional(rollbackFor=Exception.class)</code>，否则会导致事务失效，数据commit造成数据不一致，所以有些时候try catch反倒会画蛇添足。</p><h4 id="6、数据库引擎不支持事务"><a href="#6、数据库引擎不支持事务" class="headerlink" title="6、数据库引擎不支持事务"></a>6、数据库引擎不支持事务</h4><p>这种情况出现的概率并不高，事务能否生效数据库引擎是否支持事务是关键。常用的MySQL数据库默认使用支持事务的<code>innodb</code>引擎。一旦数据库引擎切换成不支持事务的<code>myisam</code>，那事务就从根本上失效了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux学习</title>
    <link href="undefined2020/03/12/linux%E5%AD%A6%E4%B9%A0/"/>
    <url>2020/03/12/linux%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-安装Centos7"><a href="#第三章-安装Centos7" class="headerlink" title="第三章 安装Centos7"></a>第三章 安装Centos7</h1><h3 id="强制使用GPT分区表"><a href="#强制使用GPT分区表" class="headerlink" title="强制使用GPT分区表"></a>强制使用GPT分区表</h3><p>​        若磁盘容量小于2TB则会默认使用MBR分区表来安装。</p><p>​        在光盘启动后安装界面按下<code>TAB</code>按键，输入<strong>inst.gpt</strong>。</p><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>​        所有的配置信息，包括root的密码等都会被记录到<strong>/root/anaconda-ks.cfg</strong>这个文件内。重建系统时，可以参考该文件。</p><h3 id="指令学习"><a href="#指令学习" class="headerlink" title="指令学习"></a>指令学习</h3><ol><li><code>echo $LANG</code>和<code>locale</code>可以获得终端支持的语系数据。</li><li><code>date</code>可显示日期，<code>cal</code>可显示日历，<code>bc</code>可作为计算器。</li><li><code>man</code>和<code>info</code>为常见的帮助指令。</li><li><kbd>ctrl</kbd>+<kbd>alt</kbd>+<kbd>F1~6</kbd>可以切换tty1～6</li><li>man page的数字中，1代表一般账号可用命令，8代表系统管理员可用，5代表系统配置文件格式。</li></ol><h1 id="第五章-Linux的文件权限与目录配置"><a href="#第五章-Linux的文件权限与目录配置" class="headerlink" title="第五章 Linux的文件权限与目录配置"></a>第五章 Linux的文件权限与目录配置</h1><h3 id="文件的类型和权限"><a href="#文件的类型和权限" class="headerlink" title="文件的类型和权限"></a>文件的类型和权限</h3><p>​    文件类型和权限表示为如：<strong>-rwxrwx—</strong></p><ul><li>第一个字符表示文件类型：d为目录，-为文件，l为链接文件等</li><li>接下来的字符，以三个为一组，依次为用户(user)，群组(group)，其他用户(other)</li><li>rwx可以用数字来表示，分别为4，2，1。</li></ul><h3 id="文件属性与权限的修改（P157）"><a href="#文件属性与权限的修改（P157）" class="headerlink" title="文件属性与权限的修改（P157）"></a>文件属性与权限的修改（P157）</h3><ul><li><code>chgrp</code>修改文件所属用户组</li><li><code>chown</code>修改文件拥有者</li><li><code>chmod</code>修改文件权限</li></ul><h3 id="目录与文件的权限意义"><a href="#目录与文件的权限意义" class="headerlink" title="目录与文件的权限意义"></a>目录与文件的权限意义</h3><ol><li><p><strong>文件</strong></p><ul><li><p>r：可读取此文件的实际内容。</p></li><li><p>w：可以编辑、新增或是修改文件的内容（但不含删除该文件）。</p></li><li><p>x：该文件具有可以被系统执行的权限。（与windows不同，windwos是通过扩展名决定此文件是否可以被执行）</p></li></ul></li><li><p><strong>目录</strong></p><ul><li><p>r：表示具有读取目录结构的权限，即可以使用ls列出内容列表（但是无法查看除文件名的其他信息，会显示问号。）</p></li><li><p>w：表示具有改动该目录结构列表的权限</p><ul><li><p>建立新的文件与目录；</p></li><li><p>删除已经存在的文件与目录；</p></li><li><p>将已存在的文件或目录进行更名；</p></li><li><p>移动该目录内的文件、目录位置；</p></li></ul></li><li><p>x：表示用户能否进入该目录成为工作目录，即能否cd进去。</p></li></ul></li></ol><p>#第六章 Linux文件与目录管理</p><h3 id="命令学习"><a href="#命令学习" class="headerlink" title="命令学习"></a>命令学习</h3><table><thead><tr><th>命令</th><th align="center">含义</th></tr></thead><tbody><tr><td>cd -</td><td align="center">返回前一个工作目录</td></tr><tr><td>pwd -P</td><td align="center">显示正确的文件路径，而不是链接文件路径（仅在链接文件中使用有区别）</td></tr><tr><td>mkdir -[mp]</td><td align="center">-m：直接设置权限（如777），-p：自动创建所需要的文件夹</td></tr><tr><td>ls</td><td align="center">P181</td></tr><tr><td>cp</td><td align="center">P183（常用-a，-i，-p，-r）</td></tr><tr><td>basename</td><td align="center">获取最后的文件名</td></tr><tr><td>dirname</td><td align="center">获取目录名</td></tr></tbody></table><h3 id="关于执行文件的路径变量：-PATH"><a href="#关于执行文件的路径变量：-PATH" class="headerlink" title="关于执行文件的路径变量：$PATH"></a>关于执行文件的路径变量：$PATH</h3><p>​        ls等命令能直接执行是因为环境变量中有/bin目录。使用<code>$ PATH=&quot;${PATH}:/xxx&quot;</code>可以把/xxx也加入环境变量中，即/xxx下的可执行文件也可以在任意地方被使用。</p><h3 id="文件内容查看命令"><a href="#文件内容查看命令" class="headerlink" title="文件内容查看命令"></a>文件内容查看命令</h3><p>（可以使用sublime3）</p><table><thead><tr><th align="left">命令</th><th align="center">使用情景</th></tr></thead><tbody><tr><td align="left">cat</td><td align="center">查看行数较少的文本，可以添加行标</td></tr><tr><td align="left">less</td><td align="center">查看行数较多的文本</td></tr><tr><td align="left">head/tail(-f:持续查看)</td><td align="center">查看文件头尾</td></tr><tr><td align="left">od(-d oCc:显示ASCII10进制对照表)</td><td align="center">查看非文本文件</td></tr></tbody></table><h3 id="修改文件时间或创建新文件：touch"><a href="#修改文件时间或创建新文件：touch" class="headerlink" title="修改文件时间或创建新文件：touch"></a>修改文件时间或创建新文件：touch</h3><p>Linux下文件的有三个主要变动的时间参数：</p><ol><li><strong>修改时间（modification time, mtime）</strong></li><li><strong>状态时间（change time, ctime）</strong></li><li><strong>读取时间（access time, atime）</strong></li></ol><p>​        在ll下显示出来的是mtime，可以通过添加<code>--time=ctime/-c</code>或<code>--time=atime/-a</code>显示另外两种时间。（Linux下可以使用<strong>;</strong>分割执行多条任务）</p><p>​        或者使用<strong><code>stat filename</code></strong>也可查看文件的3条时间信息。</p><p>​        <strong>可以使用touch修改文件的mtime和atime，但无法修改文件的ctime。而且在touch一个文件时，文件的ctime会变成目前时间。</strong></p><h3 id="文件默认权限"><a href="#文件默认权限" class="headerlink" title="文件默认权限"></a>文件默认权限</h3><p>​        可以使用<code>umask -S</code>查看，文件对象默认将x权限都去除。使用<code>umask [002]</code>可以直接设置umask的值。</p><h3 id="文件的隐藏权限"><a href="#文件的隐藏权限" class="headerlink" title="文件的隐藏权限"></a>文件的隐藏权限</h3><p>​        使用<code>lsattr</code>查看，使用<code>chattr</code>修改。比较重要的有<strong>a（只能增加内容）</strong>和<strong>i（对此文件的任何操作都不允许）</strong>两个属性。</p><h3 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h3><ol><li><strong>SUID（Set UID）</strong>：当s标志出现在文件拥有者的x权限上时。仅限对二进制程序有效，执行者在执行此程序时将获得拥有者的权限。（如/usr/bin/passwd命令）</li><li><strong>SGID（Set GID）</strong>：当s标志出现在文件用户组的x权限上时。<ul><li>对于文件来说：仅限对二进制程序有效，执行者在执行此程序时将获得用户组的权限。（如/usr/bin/locate命令）</li><li>对于目录来说：若用户在此目录下具有w权限，则用户所建立的新文件，该新文件的用户组与此目录的用户组相同。<strong><em>（问题：不是很明白有什么用）</em></strong></li></ul></li><li><strong>SBIT（Sticky Bit）</strong>：当t标志出现在文件其他人的x权限上时。仅对目录有效，用户在该目录下新建的文件或目录，只有他自己和root有权利删除。</li></ol><p><strong>特殊权限的设置方法</strong>：在3个权限数字前再加一个数字，SUID：4；SGID：2；SBIT：1。</p><h3 id="观察文件类型"><a href="#观察文件类型" class="headerlink" title="观察文件类型"></a>观察文件类型</h3><p>​        使用<code>file</code>命令。</p><h3 id="命令与文件的查询"><a href="#命令与文件的查询" class="headerlink" title="命令与文件的查询"></a>命令与文件的查询</h3><ul><li><strong>命令的查询</strong>：<code>which [-a]</code> ，它是根据[Path]这个环境变量所规范的路径去查找执行文件的文件名。</li><li><strong>文件的查询</strong><ul><li><strong>whereis</strong>：查找特定文件夹下的一些文件，使用<code>whereis -l</code>可以看到查找的是哪些文件夹。</li><li><strong>locate</strong>：使用已经建立的数据库中查找文件（centos7是每天更新一次），优点是可以模糊匹配，缺点是找不到新创建的文件。使用<code>updatedb</code>可以手动更新数据库。</li><li><strong>find</strong>：功能多，速度慢。</li></ul></li></ul><h1 id="第七章-Linux磁盘与文件系统管理"><a href="#第七章-Linux磁盘与文件系统管理" class="headerlink" title="第七章 Linux磁盘与文件系统管理"></a>第七章 Linux磁盘与文件系统管理</h1><h3 id="磁盘分区格式"><a href="#磁盘分区格式" class="headerlink" title="磁盘分区格式"></a>磁盘分区格式</h3><p>​        扇区为最小分区单位（早起为柱面），主要有512B和4KB两种格式。</p><ol><li><p><strong>MBR分区表</strong>：第一个扇区有512字节。</p><ul><li><p>主引导记录（Master Boot Record）：可以安装启动引导程序的地方，有446字节；</p></li><li><p>分区表（partition table）：记录整块硬盘分区的状态，有64字节</p></li></ul></li><li><p><strong>GPT分区表</strong>：分区数量扩充较多，支持的磁盘容量可以超过2TB。</p></li></ol><h3 id="文件系统特性"><a href="#文件系统特性" class="headerlink" title="文件系统特性"></a>文件系统特性</h3><p>​        传统的磁盘与文件系统中，一个分区只能被格式化为一个文件系统。现在一个分区可以被格式化为多个文件系统，多个分区也可以被格式化为一个文件系统。因此我们通常称<strong>一个可被挂载的数据为一个文件系统而不是一个分区</strong></p><h4 id="文件系统的数据存取方式"><a href="#文件系统的数据存取方式" class="headerlink" title="文件系统的数据存取方式"></a>文件系统的数据存取方式</h4><ol><li><strong>索引式文件系统</strong>：根据inode找到此文件的所有数据区块，不太需要碎片整理，如ext2。</li><li><strong>链式文件系统</strong>：需要将区块一个个读出来后，才能知道下一个区块的位置，需要不时的进行碎片整理，否则文件读取性能会很差，如FAT。</li></ol><h3 id="Linux的ext2文件系统"><a href="#Linux的ext2文件系统" class="headerlink" title="Linux的ext2文件系统"></a>Linux的ext2文件系统</h3><p>​        ext2文件系统格式化的时候会区分成多个区块群组（block group），在最前面有个启动扇区（boot sector），这个扇区可以安装启动引导程序。(ext2文件系统示意图p212)</p><p><strong>每个区块群组的六个主要内容如下</strong>：</p><ol><li><p><strong>数据区块（data block）</strong>：实际记录文件的内容。在ext2中所支持的区块大小有1K、2K以及4K。不同的区块大小有不同的<strong>最大单一文件限制</strong>和<strong>最大文件系统总容量</strong>。每个区块最多只能放置一个文件，因此不合适的区块大小选择会产生严重的空间浪费。</p></li><li><p><strong>inode表（inode table）</strong>：记录了文件属性和权限等一些信息。系统读取文件时需要先找到inode，并分析inode所记录的权限与用户是否符合，若符合才能够读取分区块的内容。</p><p>采用索引式文件系统，并且通过间接，双间接，三简接来扩大了最大单一文件限制。</p></li><li><p><strong>超级区块（Superblock）</strong>：记录此文件系统的整体信息，包括inode与数据区块的总量、使用量、剩余量，以及文件系统的格式与相关信息等。除了第一个区块群组的超级区块之外，后续若含有超级区块也是作为第一个的备份。</p></li><li><p><strong>区块对照表（block bitmap）</strong>：记录数据区块的使用情况，如未使用、已占用等。</p></li><li><p><strong>inode对照表（inode bitmap）</strong>：记录inode区块的使用情况。</p></li><li><p><strong>文件系统描述（Filesystem Description）</strong>：描述每个区块群组开始与结束的区块，以及说明每个区段分别介于哪一个区块之间。</p></li></ol><p><strong>可以用<code>dump2fs</code>查询ext系列超级区块的信息，centos7默认使用的是xfs文件系统，因此无法使用此命令</strong></p><h3 id="ext2文件读取与目录树的关系"><a href="#ext2文件读取与目录树的关系" class="headerlink" title="ext2文件读取与目录树的关系"></a>ext2文件读取与目录树的关系</h3><p>​        在Linux下创建一个目录时，文件系统会分配一个inode与至少一个区块给该目录（目录下的文件数过多则会继续分配区块给这个目录）。文件的文件名和占用的inode号码都被存储在此目录的区块中。因此文件的增删改和目录的权限有关，对于文件的访问是从根目录开始读起的。具体例子见P218。</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>centos7</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java编程思想</title>
    <link href="undefined2020/03/10/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    <url>2020/03/10/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-对象导论"><a href="#第一章-对象导论" class="headerlink" title="第一章 对象导论"></a>第一章 对象导论</h1><h3 id="访问控制的原因"><a href="#访问控制的原因" class="headerlink" title="访问控制的原因"></a>访问控制的原因</h3><ol><li>为了让客户端程序员无法触及他们不应该触及的部分</li><li>允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员</li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>区分前期绑定和后期绑定</p><h3 id="泛型出现的原因"><a href="#泛型出现的原因" class="headerlink" title="泛型出现的原因"></a>泛型出现的原因</h3><p>​        java SE5之前容器中只能存储Object对象，即当对象从容器中取出时需要向下转型为程序员需要的类型，然而除非知道所要处理的对象类型，这种转换是不安全的。<strong>向下转型和运行时的检查需要额外的程序运行时间（<em>java的泛型不能优化这部分时间，使用泛型的话向下转型依然存在（归咎于擦除机制），但是是由编译器自动帮你完成 P380</em>），也需要程序员付出更多的心血。</strong></p><h3 id="对象创建的生命周期"><a href="#对象创建的生命周期" class="headerlink" title="对象创建的生命周期"></a>对象创建的生命周期</h3><ol><li>在编写程序的时候确定对象的存储空间和生命周期。可以通过将对象置于栈中（有时被称为automatic variable或scoped variable）或静态存储区域来实现。</li><li>在被称为堆的内存池中动态地创建对象。</li></ol><h1 id="第二章-对象"><a href="#第二章-对象" class="headerlink" title="第二章 对象"></a>第二章 对象</h1><h3 id="程序运行时，对象可以存在的位置"><a href="#程序运行时，对象可以存在的位置" class="headerlink" title="程序运行时，对象可以存在的位置"></a>程序运行时，对象可以存在的位置</h3><ol><li>寄存器</li><li>栈</li><li>堆：通用的对象池，用于存放所有的java对象。</li><li>常量存储</li><li>非RAM存储</li></ol><h3 id="高精度数字"><a href="#高精度数字" class="headerlink" title="高精度数字"></a>高精度数字</h3><p>BigInteget和BigDecimal</p><h3 id="获取系统信息"><a href="#获取系统信息" class="headerlink" title="获取系统信息"></a>获取系统信息</h3><pre><code class="java">System.getProperties().list(System.out);System.out.println(System.getProperty(&quot;user.name&quot;));System.out.println(System.getProperty(&quot;java.library.path&quot;));</code></pre><h1 id="第五章-初始化与清理"><a href="#第五章-初始化与清理" class="headerlink" title="第五章 初始化与清理"></a>第五章 初始化与清理</h1><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><ol><li>方法名相同而参数列表不同。</li><li>基本类型的参数重载，如果没有找到char，char会提升至int。</li><li>返回值不能用来区分重载方法。</li></ol><p>###什么时候需要使用finalize()</p><ol><li>当在java类中调用非java代码时，如c/c++，需要在finalize()中释放其占据的内存。一般情况下不需要使用finalize()</li><li>用于对象<strong>终结条件</strong>的验证，用于发现错误，之后也需要去除（使用<code>System.gc()</code>可以强制进行垃圾回收）</li></ol><h3 id="垃圾回收器的工作原理"><a href="#垃圾回收器的工作原理" class="headerlink" title="垃圾回收器的工作原理"></a>垃圾回收器的工作原理</h3><p>​    java采用<strong>自适应</strong>的垃圾回收机制（见Java编程思想第四版P89）</p><h3 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h3><p>​    基本类型作为局部变量必须被初始化，而作为成员变量，会获得自己默认的初始值。对象类型的初始值为null。</p><h3 id="类的初始化过程"><a href="#类的初始化过程" class="headerlink" title="类的初始化过程"></a>类的初始化过程</h3><ol><li><p>因为构造器为静态函数，因此首次创建此类或者类的静态方法/静态域首次被访问时，Java解释器必须找到类路径，以定位xxx.class文件。</p></li><li><p>然后载入xxx.class，有关静态初始化的所有动作都会被执行，且只执行这一次。</p></li><li><p>当用new xxx()创建对象的时候，首先将在堆上为对象分配足够的存储空间。</p></li><li><p>将这块存储空间清0，这时所有的基本类型成员被设置成了默认值，对象成员被设置成了null。</p></li><li><p>若此类继承了其他类，则按照继承顺序依次进行初始化，初始化步骤为如下：</p><ol><li><p>执行所有字段定义处的初始化动作。</p></li><li><p>执行构造器。</p></li></ol></li></ol><p><strong>PS：当程序创建第一个对类的静态成员的引用时，就会加载这个类</strong></p><h1 id="第七章-复用类"><a href="#第七章-复用类" class="headerlink" title="第七章 复用类"></a>第七章 复用类</h1><h3 id="final关键词"><a href="#final关键词" class="headerlink" title="final关键词"></a>final关键词</h3><ol><li><strong>数据</strong>：final通常用于基本类型变量。若用于对象类型则表示此引用不能改变，而引用指向的对象的值依然可以改变，因此没有太大意义。</li><li><strong>方法</strong>：明确禁止覆写。</li><li><strong>类</strong>：明确禁止继承。</li></ol><h1 id="第十章-内部类"><a href="#第十章-内部类" class="headerlink" title="第十章 内部类"></a>第十章 内部类</h1><ol><li><p>普通内部类(inner class)：内部类通常继承自某个类或者实现了某个接口，它是一个独立的实体，因此通常以匿名类的方式出现。若内部类被多次使用，才将他显示的定义出来。很少情况下会在外部使用内部类。</p><p><strong>每个内部类都能独立的继承自一个（接口的）的实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</strong></p></li><li><p>静态内部类(nested class)</p></li></ol><h1 id="第十一章-持有对象"><a href="#第十一章-持有对象" class="headerlink" title="第十一章 持有对象"></a>第十一章 持有对象</h1><h3 id="添加一组元素"><a href="#添加一组元素" class="headerlink" title="添加一组元素"></a>添加一组元素</h3><ol><li><p><strong>Array.asList()</strong>：返回的是以数组为底层的List，<strong>因此对其添加或删除元素会抛出Unsupported Operation</strong>。可以使用<code>Collection.add(Array.asList())</code>。</p><p><code>new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3))</code>可以用来初始化List。</p><p><code>Arrays.&lt;Integer&gt;asList(1, 2, 3)</code>可以显示的指定类型。</p></li><li><p><strong>Collections.add()</strong>：返回boolean。</p></li></ol><h3 id="各种容器的区别"><a href="#各种容器的区别" class="headerlink" title="各种容器的区别"></a>各种容器的区别</h3><ul><li><p><strong>List</strong></p><ul><li><strong>ArrayList</strong>：按照插入顺序保存元素，随机访问元素的速度较快。retainAll()求交集。</li><li><strong>LinkedList</strong>：按照插入顺序保存元素，增加删除元素的速度较快。包含的操作多于ArrayList。<strong>其中多出的操作可以使其作栈、队列和双端队列的方法</strong>。</li></ul></li><li><p><strong>Set</strong></p><ul><li><strong>HashSet</strong>：保存顺序无意义，获取元素的速度最快。<strong>专门对快速查找进行了优化</strong>。使用散列存储。</li><li><strong>TreeSet</strong>：按照比较结果的升序保存数据，也可以按照降序。使用红-黑树存储。</li><li><strong>LinkedHashSet</strong>：按照插入顺序保存元素，同时保存了HashSet的查询速度。使用散列存储。</li></ul></li><li><p><strong>Map</strong></p><ul><li><strong>HashMap</strong>：同Set。</li><li><strong>TreeSet</strong>：同Set。</li><li><strong>LinkedHashMap</strong>：同Set。</li></ul></li></ul><h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p>​        ListIterator只能用于各种List类的访问。它是一个双向迭代器。</p><h3 id="一些容器的介绍"><a href="#一些容器的介绍" class="headerlink" title="一些容器的介绍"></a>一些容器的介绍</h3><ul><li><p><strong>LinkedList</strong>：可以实现栈和队列的功能。是Deque的一个实现。</p></li><li><p><strong>stack</strong>：Java1.0中的Stack设计欠佳（Vector也是）。推荐使用LinkedList来重新实现。</p></li><li><p><strong>Set</strong>：主要用于查询，可以进行很多集合操作，如交，并，差，包含（<a href="#set-math">需要自己实现</a>）等。</p><ul><li>TreeSet默认使用字典序排序，传入<code>String.CASE_INSENSITIVE_ORDER</code>可以使用字母序排序，也可以构造自己规定的Comparator比较器。</li></ul></li><li><p><strong>Map</strong>：很厉害。</p></li><li><p><strong>Queue</strong>：LinkedList为其一个实现（LinkedList实现了Deque，Deque继承自Queue），因此可以将LinkedList向上转型，使其使用更加清晰。</p><ul><li><strong>PriorityQueue</strong>：优先级队列，默认以字典序降序排列（可以构造自己规定的Comparator比较器），是Queue的一个具体实现。底层实现是<strong>堆</strong>的结构，因此直接遍历输出是无序的，需要一个一个出队才可以有序。另外，<strong>无法改变元素等待时在容器中的优先度</strong>。</li></ul></li></ul><p>#####对于LinkedList的见解：</p><p><strong><em>它同时实现了List和Deque接口，同时具备了List和Dqeue的特性，这也是其拥有许多功能类似甚至相同的方法。</em></strong></p><p><strong><em>它就像是一个大杂烩，有许多使用场景：</em></strong></p><ol><li><strong><em>当需要使用Collection的特性时，且会对容器内的元素进行频繁的增删改时，适合直接使用。</em></strong></li><li><strong><em>当需要使用Stack的特性时，可以将其重新封装，只暴露出符合Stack特性的方法来使用。</em></strong></li><li><strong><em>当需要使用Queue的特性时，可以将其向上转型为Queue，Deque也是如此。</em></strong></li></ol><h3 id="Foreach语句"><a href="#Foreach语句" class="headerlink" title="Foreach语句"></a>Foreach语句</h3><p>​        只要实现了Iterable接口实现了Iterator方法的类都可以使用foreach，即foreach的本质就是迭代器的简化写法。<strong><em>（问题：那么数组为什么能使用foreach？）</em></strong></p><p><strong>PS：使用适配器模式可以实现更多的使用Iterator的遍历方法</strong>。</p><p>#第十二章 异常处理</p><h3 id="创建自定义异常"><a href="#创建自定义异常" class="headerlink" title="创建自定义异常"></a>创建自定义异常</h3><pre><code class="java">class SimpleException extends Exception {    SimpleException() {}    SimpleException(String msg) {        super(msg);    }}</code></pre><h3 id="日志与异常"><a href="#日志与异常" class="headerlink" title="日志与异常"></a>日志与异常</h3><pre><code class="java">// 构造一个可以记录日志信息的Logger，不过现在已经用更成熟的日志框架了（如log4j）class LoggingException {    private static Logger logger = Logger.getLogger(&quot;LoggingException&quot;);    static void log(Exception e) {        StringWriter trace = new StringWriter();        e.printStackTrace(new PrintWriter(trace));        logger.info(trace.toString());    }}</code></pre><h3 id="throws关键字"><a href="#throws关键字" class="headerlink" title="throws关键字"></a>throws关键字</h3><p>​        紧跟在方法后面，方便方法使用者知道这个方法会抛出什么样的异常，优雅。</p><h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>没有cause参数的异常类需要使用initCause添加异常链。表明引发这个异常的根本异常。</p><pre><code class="java"> SimpleException simpleException = new SimpleException(); simpleException.initCause(new NullPointerException()); throw simpleException;</code></pre><p>###RuntimeException</p><p>​        java虚拟机会自动抛出这一类异常，无需手动抛出。因为它代表的是<strong>编程错误</strong>。</p><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>​        finally里的语句一定会执行，即使try中已经执行了break，continue或者return。<strong>但是finally语句的错误使用可能会发生异常丢失（JDK5的书上如此写到，不知道JDK8是否已经修复）</strong></p><h3 id="异常的限制"><a href="#异常的限制" class="headerlink" title="异常的限制"></a>异常的限制</h3><p>​        当覆写方法时，只能抛出基类方法的异常说明里列出的那些异常。</p><p>​        派生类的构造器不能捕获它基类构造器所抛出的异常，<strong>因为super()（对基类构造器的调用）必须位于首行</strong>。</p><h3 id="异常匹配"><a href="#异常匹配" class="headerlink" title="异常匹配"></a>异常匹配</h3><p>​        异常类中，派生类也可以匹配基类的处理程序。</p><p><strong>PS：千万不能吞食异常，即在catch语句中不输出任何错误</strong>。</p><h1 id="第十三章-字符串"><a href="#第十三章-字符串" class="headerlink" title="第十三章 字符串"></a>第十三章 字符串</h1><p>###StringBuilder</p><p>​        <strong>就结论而言，循环对字符串做加减应该使用StringBuilder。（或者StringBuffer，因为是线程安全的，效率比StringBuilder差一点）</strong></p><p>​        简单的字符串运算，jvm会自动优化使用StringBuilder。但是在循环操作时候，jvm优化会产生多个StringBuilder，因此效率依然低于直接使用StringBuilder。</p><p><strong>PS：java -c可以反编译产生jvm字节码。在不确定程序效率的时候可以使用这个命令查看</strong>。</p><h3 id="重写toString-方法的坑"><a href="#重写toString-方法的坑" class="headerlink" title="重写toString()方法的坑"></a>重写toString()方法的坑</h3><p>​        重写此方法要注意避免<strong>无意识的递归</strong>。例如，在toString()中使用<code>&quot;a&quot; + this</code>，会触发调用this的toString()方法，产生递归调用。要输出对象的内存地址，这里应该使用<code>super.toString()</code>。</p><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><ol><li><code>System.out.format()和System.out.printf()</code>两者用法与C语言中的printf一致。</li><li><code>String.format()</code>调用Formatter的静态函数实现格式化String，返回值为一个String对象。</li></ol><p>###正则表达式</p><p>​        与其他语言的正则表达式不同，P295页有解释。</p><p>​        具体表现为：在出现 <strong>\</strong> 的时候需要再多加一个 <strong>\</strong> 。如\d变为\\d、\\变为\\\\、\|变为\\|。</p><p>#####对于转义的理解：</p><p>​        <strong><em>有很多地方都有不同的转义需求，通常使用 \ 作为转义字符。转义不仅仅局限于高级编程语言当中，例如目前学习到的正则表达式，甚至笔者正在使用的markdown编辑格式中都有转义的需求。在不同地方需要转义的字符也不同。如字符*，在高级编程语言中不需要转义，而在regex和md中各有特殊含义，因此需要转义。</em></strong></p><p>​        <strong><em>将转义的范围局限于高级编程语言所规定的字符中，将影响对其他地方使用到的转义进行理解。</em></strong></p><p>​        <strong><em>在java中使用regex的例子更加特殊，因为它们同时使用 \ 作为转义字符，而在java中 \ 也是需要转义的字符。当在regex使用转义字符 \ 时，需要现在java中先将 \ 转义，这也为什么在java中使用正则表达式需要多加一个 \ 的原因。</em></strong>（其实在别的高级语言中也是如此，但是因为python有r，c#有@可以取消高级语言造成的转义（即废除 \ 在语言中作为转义字符的作用），js貌似也有取消转义的方式（好像是用/将字符串包围起来）。当java中也出现这种功能时，我们也就不必再为此感到纠结了）</p><p>^和$的作用：^表示从头匹配，$表示从尾匹配。</p><p>###量词</p><ul><li><strong>贪婪型</strong>：不做如何改变，最长匹配。</li><li><strong>勉强型</strong>：在原来的正则表达式后面多加一个<strong>?</strong>，最短匹配。</li><li><strong>占有型</strong>：在原来的正则表达式后面多加一个<strong>+</strong>，java特有的类型。（不知道有什么用）</li></ul><p>###一些重要的地方</p><ul><li>Matcher对象以括号次序分组，原始的正则匹配式为第0组。</li><li>Pattern标记，比较重要的有<strong>Pattern.CASE_INSENSITIVE(?i)</strong>、<strong>Pattern.MULTILINE(?i)</strong>以及<strong>Pattern.COMMENTS(?x)</strong></li><li>appendReplacement()，当被替换的字符与替换它的字符存在转化关系时使用。（如大写变小写）</li><li>Scanner类可以用正则表达式对输入进行分词（默认为空白字符），也可以用正则表达式过滤记录。</li></ul><h1 id="第十四章-类型信息"><a href="#第十四章-类型信息" class="headerlink" title="第十四章 类型信息"></a>第十四章 类型信息</h1><h3 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h3><p>​        每一个类都有一个Class对象。Class对象包含了与类有关的信息。</p><p>​        当程序创建第一个对类的静态成员的引用时就会加载这个类。</p><table><thead><tr><th>方法</th><th align="center">含义</th></tr></thead><tbody><tr><td>Class.forName(String)</td><td align="center">静态方法。或该Class对象的引用，若找不到该加载的类，会抛出<strong>ClassNotFoundException</strong></td></tr><tr><td>Class.getInterfaces()</td><td align="center">获得这个Class对象所实现的所有接口</td></tr><tr><td>Class.getSuperclass()</td><td align="center">获得基类</td></tr><tr><td><strong>Class.newInstance()</strong></td><td align="center">会返回一个Object对象，若指定泛型，则会返回具体对象</td></tr><tr><td>Class.isInstance(Object)</td><td align="center">判断Object对象是否是此Class的一个实例</td></tr><tr><td>Class.isAssignableFrom(Class&lt;?&gt;)</td><td align="center">判断是否是子类</td></tr><tr><td>(class name).class</td><td align="center">类字面常量。返回类对象的引用，和forName的区别是不会初始化该类。基本类型也能使用。</td></tr></tbody></table><p>####使用类所需的三步骤</p><ol><li>加载</li><li>链接</li><li>初始</li></ol><p>其中初始化被延迟到了对静态方法（构造器隐式的也是静态的）或者非常数静态域（编译期常量）进行首次引用（<strong>对static final int a = 1的引用是不会引起类的初始化的</strong>）</p><h4 id="泛化的Class引用"><a href="#泛化的Class引用" class="headerlink" title="泛化的Class引用"></a>泛化的Class引用</h4><ol><li>Class&lt;?&gt;优于平凡的Class</li><li>Class&lt;? extends Number&gt;和Class&lt;? super Integer&gt;的含义（类比到盘子和盘子内的物品，<strong><em>拓展：PECS理论</em></strong>）</li><li>新的类型转换方式，Class&lt;T&gt;.cast(Object)会将Object对象转型到T。（<strong>几乎在所有的场合都可以使用普通的类型转换代替</strong>）</li></ol><p>###RTTI的三种形式</p><ol><li>传统的类型转换。如(Shape)，RTTI（Run-Time Type Identification）保证了类型转换的正确性。（只有向下转型时需要，向上转型是安全的）。</li><li>代表对象类型的Class对象。</li><li>关键词instanceof。(可以用Class.isInstance()代替)</li></ol><p><strong>P331的工厂模式的实现方法挺独特的（将工厂作为内部类实现，即每个类都有一个自己的工厂）</strong></p><p>###反射</p><h4 id="RTTI和反射的区别"><a href="#RTTI和反射的区别" class="headerlink" title="RTTI和反射的区别"></a>RTTI和反射的区别</h4><p>​        RTTI来说，编译器编译时打开和检查.class文件。对于反射来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件。</p><table><thead><tr><th align="left">方法</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">Class.getMethods()</td><td align="center">获得类的所有方法，类型为Method</td></tr><tr><td align="left">Class.getFields()</td><td align="center">获得类的所有字段，类型为Field</td></tr><tr><td align="left">Class.getConstructor()</td><td align="center">获得类的所有的构造器，类型为Constructor&lt;?&gt;</td></tr></tbody></table><p>Method、Field和Constructor都实现了Member接口</p><p>####动态代理</p><pre><code class="java">public class DynamicProxyDemo {    public static void main(String[] args) {        A proxy = (A) Proxy.newProxyInstance(A.class.getClassLoader(), new Class&lt;?&gt;[]{A.class},                new DemoHandler(new B()));        proxy.doSomething();        proxy.doElse(&quot;test&quot;);    }}class DemoHandler implements InvocationHandler {    private Object proxied;    DemoHandler(Object proxied){        this.proxied = proxied;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;proxy class: &quot; + proxy.getClass() + &quot;\nMethod: &quot; + method.getName() +                &quot;\n args: &quot; + Arrays.toString(args));        method.invoke(proxied, args);        System.out.println(&quot;==============invoke over=============&quot;);        return null;    }}interface A {    void doSomething();    void doElse(String msg);}class B implements A{    @Override    public void doSomething() {        System.out.println(&quot;doSomething&quot;);    }    @Override    public void doElse(String msg) {        System.out.println(&quot;do &quot; + msg);    }}</code></pre><p>也可以使用内部类将main里的函数简化为（使用了lamda表达式，JDK8支持）：</p><pre><code class="java">A proxy = (A) Proxy.newProxyInstance(A.class.getClassLoader(), new Class&lt;?&gt;[]{A.class},        (proxy1, method, args1) -&gt; {            System.out.println(&quot;proxy class: &quot; + proxy1.getClass() + &quot;\nMethod: &quot; + method.getName() +                    &quot;\n args: &quot; + Arrays.toString(args1));            method.invoke(new B(), args1);            System.out.println(&quot;==============invoke over=============&quot;);            return null;        });proxy.doSomething();proxy.doElse(&quot;test&quot;);</code></pre><p>（P415用动态代理实现混型，很好的一个例子）</p><h4 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h4><p>​        这是一种将null也变为一个对象的设计模式。具体实现见P341。</p><h4 id="突破访问权限"><a href="#突破访问权限" class="headerlink" title="突破访问权限"></a>突破访问权限</h4><p>​        使用java反射的特性可以访问到包括private的所有成员方法和变量，不受访问修饰符的限制。</p><h1 id="第十五章-泛型"><a href="#第十五章-泛型" class="headerlink" title="第十五章 泛型"></a>第十五章 泛型</h1><p>基本类型无法作为类型参数，但是java有autoboxing和unboxing，因此使用基本类型的封装类型即可。</p><h3 id="泛型的一些使用场景"><a href="#泛型的一些使用场景" class="headerlink" title="泛型的一些使用场景"></a>泛型的一些使用场景</h3><ol><li><p><strong>实现元祖</strong>：P354结合P366，和python中的元祖功能一样。java没有内置元祖，需要自己实现。</p></li><li><p><strong>通用容器</strong>：可以事前知道容器中存储的对象类型，但实际上是“窄化”了容器。</p></li><li><p><strong>泛型接口</strong>：用于接口，实现例如 通用生成器 等。P358和P364（这个比较好）</p></li><li><p><strong>泛型方法</strong>：使用泛型方法时，类不一定需要是参数化的。</p><pre><code class="java">public &lt;T&gt; void f(T x){  System.out.println(x.toString());}</code></pre><p>而且使用泛型方法的时候<strong>不必指明参数类型</strong>，因为编译器会为我们找到具体的类型。这称为<strong>类型参数推断（type argument inference）</strong>。</p><p><strong>注意</strong>：再将泛型方法的调用结果作为参数传递给另一个方法时，编译器不会执行类型推断，返回值将被赋给一个Object类型的变量。</p></li><li><p><span id="set-math">P367实现了Set的各种数学关系式。</span></p></li><li><p>在泛型与数组结合使用会产生很多很多问题。P383</p></li></ol><h3 id="擦除"><a href="#擦除" class="headerlink" title="擦除"></a>擦除</h3><p>​        Java泛型是使用擦除来实现的。<strong>与c++不同，Java在泛型代码内部是无法调用任何有关实际使用类型的方法和变量的</strong>。如List&lt;String&gt;和List&lt;Integer&gt;在运行时事实上是相同的类型，运行期间都会变成List（这里的String 和 Integer 仅仅是给编译器做编译的时候检查用的）。无法在类方法内部调用String或Integer类型对象的方法，只能调用Object的方法，这就是Java的擦除。泛型类型只有在静态类型检查期间才出现，之后全都会被擦除。</p><p>​        <strong>泛型类型参数将被擦除到它的第一个边界（它可能会有多个边界），Raw use of parameterized class其实就是被擦除后的样子</strong>。这个边界默认是Object，可以使用<strong>&lt;T extends A&gt;</strong>将边界提升到类型A。</p><p>​        因此在使用泛型的时候我们需要无时不刻的提醒自己，泛型T最终只是一个Object类型对象（或是其他边界），而不是我们真正传入的类型。</p><p>​        为什么要有擦除？因为<strong>迁移兼容性</strong>。是为了兼容SE5之前的非泛型代码，它是被迫的，但是必须的。</p><h3 id="不适合的向上转型"><a href="#不适合的向上转型" class="headerlink" title="不适合的向上转型"></a>不适合的向上转型</h3><pre><code class="java">//这里的向上转型是不适合的Fruit[] fruits = new Apple[10];//泛型在编译期就解决了这个问题List&lt;Fruit&gt; fruitList = new ArrayList&lt;Apple&gt;();// compile error// 通配符的使用建立了容器的向上转换，但不能添加元素了List&lt;? extends Fruit&gt; fruits1 = new ArrayList&lt;Apple&gt;();fruits1.add(new Apple()); // compile error</code></pre><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><table><thead><tr><th>类型</th><th>T get()</th><th>set(T)</th></tr></thead><tbody><tr><td>原生</td><td>返回Object</td><td>参数类型为Object（warning）</td></tr><tr><td>&lt;?&gt;</td><td>返回Object</td><td>error</td></tr><tr><td>&lt;? extends T&gt;</td><td>返回T</td><td>error</td></tr><tr><td>&lt;? super T&gt;</td><td>error</td><td>参数类型为T和T的子类</td></tr><tr><td>&lt;T&gt;</td><td>返回T</td><td>参数类型为T和T的子类</td></tr></tbody></table><h3 id="自限定类型"><a href="#自限定类型" class="headerlink" title="自限定类型"></a>自限定类型</h3><pre><code class="java">class SelfBounded&lt;T extends SelfBounded&lt;T&gt;&gt; {}// 为了如下使用class A extends SelfBounded&lt;A&gt; {}</code></pre><p>具体见P404</p><p><strong><em>java类库中的Comparable接口没有使用这种方法，我觉得可以改成自限定类型，毕竟只有相同类型才可以比较。</em></strong></p><h3 id="动态类型安全"><a href="#动态类型安全" class="headerlink" title="动态类型安全"></a>动态类型安全</h3><p>java.util.Collections提供了一组checked方法确保SE5之前的旧式代码不会破坏你的容器。（很少用，所以SE5之后不要再使用不带泛型的容器了！！）</p><h3 id="潜在类型机制"><a href="#潜在类型机制" class="headerlink" title="潜在类型机制"></a>潜在类型机制</h3><p>这也是java的泛型和其他语言的泛型的差别。具体见P417</p><p><strong>反射是对java中缺少这一机制的最好补偿</strong>。</p><h5 id="对于泛型的理解："><a href="#对于泛型的理解：" class="headerlink" title="对于泛型的理解："></a>对于泛型的理解：</h5><p><strong><em>java的泛型其实有点尴尬，它本质上只是添加了在编译期检查语法的正确与否，程序运行时，是否使用了泛型其实完全没有区别。（确实完全一样，连编译后的字节码都一摸一样）</em></strong></p><p><strong><em>泛型应该使用在真正需要确切对象的时候（不用也行，使用的话向下转型依然存在，但是是由编译器自动帮你完成的 P380），如在一个函数中返回这个类型时，使用泛型就不需要对他进行显式的向下类型转换了（&lt;T extends HasF&gt;在这个时候也有帮助了）。就像容器中的get()方法一样，因此容器应该使用泛型。除此之外，大多数的问题在java的单根体系下都可以解决，且使用泛型只会显得代码更加繁琐，没有任何好处。（这很大程度上是由于擦除限制了泛型的实用性）</em></strong></p><p><strong><em>因此我认为java的泛型在大多数时候只是提供了一个编译期检查，为了将一些运行期间的错误在编译期间就能发现，同时让代码更加优雅。除了使用extends限定擦除的上界，不过使用场景很少。</em></strong>（我就随便说说，也不知真的假的）</p><h1 id="第十六章-数组"><a href="#第十六章-数组" class="headerlink" title="第十六章 数组"></a>第十六章 数组</h1><h3 id="Arrays的static实用方法"><a href="#Arrays的static实用方法" class="headerlink" title="Arrays的static实用方法"></a>Arrays的static实用方法</h3><p>方法前有deep的都是用于多维数组的。</p><table><thead><tr><th>方法</th><th align="center">含义</th></tr></thead><tbody><tr><td>equals()（deepEquals()）</td><td align="center">比较是否相等</td></tr><tr><td>sort()</td><td align="center">排序</td></tr><tr><td>binarySearch()</td><td align="center">对排好序的数组查找元素</td></tr><tr><td>toString（）</td><td align="center">…</td></tr><tr><td>fill()</td><td align="center">填充数组</td></tr><tr><td>hashCodee()</td><td align="center">产生数组的散列码</td></tr></tbody></table><p>###数组复制</p><p><code>System.arraycopy()</code>比使用for循环要快很多。它不会进行自动装拆箱。</p><p><strong>要点：对于对象数组的复制是浅复制</strong></p><h3 id="还需要使用数组吗"><a href="#还需要使用数组吗" class="headerlink" title="还需要使用数组吗"></a>还需要使用数组吗</h3><p>在java中使用容器代替数组几乎总是更好的选择，除非明确的测试表明用数组能提高性能，我们才需要使用数组。</p><h1 id="第十七章-容器深入研究"><a href="#第十七章-容器深入研究" class="headerlink" title="第十七章 容器深入研究"></a>第十七章 容器深入研究</h1><h3 id="Collection的可选操作"><a href="#Collection的可选操作" class="headerlink" title="Collection的可选操作"></a>Collection的可选操作</h3><p>并不是Collection接口中的所有操作都必须实现，为了防止接口爆炸。可以在还没设计好或不支持的可选方法抛出<strong>UnSupportedOperationException</strong>异常。</p><p>如Array.asList()和Collection.unmodifiableList()返回的Collection实现一样。（这两个的细粒度只在一个方法上）</p><h3 id="Set和存储顺序"><a href="#Set和存储顺序" class="headerlink" title="Set和存储顺序"></a>Set和存储顺序</h3><table><thead><tr><th>Set类型</th><th align="center">要点</th></tr></thead><tbody><tr><td>Set(interface)</td><td align="center">通过equals()函数确保对象的唯一性。默认equals()函数<strong>比较的是对象地址</strong>需要两个完全相同对象的引用才返回true</td></tr><tr><td>HashSet</td><td align="center">无序。需要调用hashCode()函数。默认hashCode()函数<strong>使用对象地址计算散列码</strong>，每个不同对象都会返回一个不同的code</td></tr><tr><td>TreeSet(继承SortedSet)</td><td align="center">自定义顺序。需要对象实现Comparable接口</td></tr><tr><td>LinkedHashSet</td><td align="center">有序的HashSet（插入顺序），也需要实现hashCode()</td></tr></tbody></table><p>equals()和hashCode()一般最好一起重写。</p><h3 id="散列和散列码"><a href="#散列和散列码" class="headerlink" title="散列和散列码"></a>散列和散列码</h3><p>散列的正常工作依赖于对象的hashCode()和equals()函数。</p><p>equals()方法必须满足下列5个条件（把这组对象定义为了一个阿贝尔群）：</p><ul><li>自反性</li><li>对称性</li><li>传递性</li><li>一致性</li><li>对任何不是null的x，x.equals(null)返回false</li></ul><h4 id="散列的具体工作原理"><a href="#散列的具体工作原理" class="headerlink" title="散列的具体工作原理"></a>散列的具体工作原理</h4><p>散列的价值在于速度，存储读取一组元素最快的数据结构是数组。所以散列把表示键的信息保存在一个数组中（HashMap使用的是一个Node&lt;K, V&gt;[]，Node&lt;K, V&gt;继承自Map.Entry&lt;K, V&gt;），散列允许算出的散列码相同，因此数组中的每一项保存的是一个list（HashMap使用了链表结构）。</p><p>#####具体步骤和伪代码</p><ol><li>使用键对象的hashCode()计算出键的散列码。</li><li>用数组的大小对散列码取余得到存储在数组中的位置。</li><li>查询这个位置是否为null<ul><li>若为null，则new一个list，并把此对象存储到这个list</li><li>否则，使用equals()函数判断在list中是否已有相同的键，没有则将此对象加入现有的list，否则将此键对应的值修改。</li></ul></li></ol><p><strong>input:</strong> The key and value</p><p><strong>Output:</strong> A array that has stored this key-value pair</p><pre><code class="pseudocode">hash_code = key.hashCode()index = hash_code mod store_array.size()if store_array[index] is null then    store_array[index] = new list    store_array[index].add(&lt;k, v&gt;)else    if the key set of store_array[index] contains key with the equals() then        store_array[index][pos of the same key].value = value    else         store_array[index].add(&lt;k, v&gt;)    end ifend if</code></pre><p>hashCode()的基本书写指导见P496</p><p>###HashMap的性能因子</p><ul><li>容量：表中桶位数</li><li>初始容量：默认16</li><li>尺寸：表中当前存储的项数</li><li>负载因子：尺寸/容量。默认为0.75。</li></ul><p>当Map中的负载超过了负载因子，会自动扩容resize()，并且再散列。（因为项在容器中的位置与容器大小有关）</p><p><strong>为HashMap选择合适的初始容量可以避免resize()带来的开销。</strong></p><p>###快速报错</p><p>这是java对容器的一种保护机制，能够防止多个进程同时修改同一个容器的内容。抛出ConcurrentModificationExecption异常。</p><p>ConcurrentMap、CopyOnWriteArrayList和CopyOnWriteArraySet都使用了可以避免这个异常的技术。</p><h1 id="第十八章-Java-I-O系统"><a href="#第十八章-Java-I-O系统" class="headerlink" title="第十八章 Java I/O系统"></a>第十八章 Java I/O系统</h1><p>DataOutputStream和DataInpuStream有什么用还不清楚。</p><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>一个File对象即能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称的名称（使用list()或listFiles()方法可以获得所有这组文件）。</p><p>使用list()方法的时候可以使用FilenameFilter进行过滤：</p><pre><code class="java">File path = new File(&quot;./src/cn/hailuo/learn/annotation&quot;);String[] list = path.list((dir, name) -&gt; {    Pattern pattern = Pattern.compile(&quot;D.+\\.java&quot;);    return pattern.matcher(name).matches();});Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);System.out.println(Arrays.toString(list));</code></pre><p>File有许多实用的方法，自行查阅jdk文档</p><h3 id="输入与输出（感觉很复杂，还没有搞清楚）"><a href="#输入与输出（感觉很复杂，还没有搞清楚）" class="headerlink" title="输入与输出（感觉很复杂，还没有搞清楚）"></a>输入与输出（感觉很复杂，还没有搞清楚）</h3><h4 id="Java1-0"><a href="#Java1-0" class="headerlink" title="Java1.0"></a>Java1.0</h4><p>主要存在4种类型（具体见P536）：</p><ol><li>InputStream：输入流。</li><li>OutputStream：输出流。</li><li>FilterInputStream：输入流的装饰类，可以扩展基本输入流的功能。</li><li>FilterOutputStream：输出流的装饰类。</li></ol><h4 id="Java1-1之后"><a href="#Java1-1之后" class="headerlink" title="Java1.1之后"></a>Java1.1之后</h4><p>对I/O流库进行了重大的修改。</p><ul><li><p>Reader类和Writer类代替了大部分的InputStream和OutputStream。但是不是完全取代。</p></li><li><p><strong>Reader和Writer继承结构的设计主要是为了国际化，提供了兼容Unicode和面向字符的I/O功能</strong></p></li><li><p>有时候需要把继承了InputStream和OutputStream的类与继承了Reader和Writer类结合起来使用。要用到适配器类，InputStreamReader（继承了Reader）和OutputStreamReader（继承了Writer）。（如FileReader继承了InputStreamReader）</p><pre><code class="java">// since 1.5// PrintWriter的一个辅助构造器，就使用了OutputStreamWriter作为适配器public PrintWriter(String fileName) throws FileNotFoundException {    this(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName))),        false);}</code></pre></li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>用BufferedReader可以提高速度。</p><p>建议用 BufferedReader 包装所有其 read() 操作可能开销很高的 Reader（如 FileReader 和 InputStreamReader）。</p><p>####输入</p><pre><code class="java">BufferedReader reader = new BufferedReader(new FileReader(filename));String s;StringBuilder sb = new StringBuilder();while ((s = reader.readLine()) != null) {    sb.append(s).append(&quot;\n&quot;);}reader.close();return sb.toString();</code></pre><p>####输出</p><pre><code class="java">// 自动包装了BufferedWriterPrintWriter writer = new PrintWriter(outFile);BufferedReader reader = new BufferedReader(new FileReader(path));String s;int count = 1;while ((s = reader.readLine()) != null) {    writer.println(count++ + &quot;: &quot; + s);}writer.close(); //不写这句话将会出错reader.close();</code></pre><pre><code class="java">// se8？新特性, 可以不用写closetry (PrintWriter writer = new PrintWriter(outFile);     BufferedReader reader = new BufferedReader(new FileReader(path))) {    String s;    int count = 1;    while ((s = reader.readLine()) != null) {        writer.println(count++ + &quot;: &quot; + s);    }}</code></pre><p><strong>java.io默认相对路径定位到当前用户目录(“user.dir”)下，即：工程根目录。</strong></p><h3 id="随机访问文件"><a href="#随机访问文件" class="headerlink" title="随机访问文件"></a>随机访问文件</h3><p>使用RandomAccessFile，类似于组合了DataOutputStream和DataInpuStream。使用seek()可以在文件中到处移动，移动单位为字节。因此它也是一个面向字节的I/O。</p><pre><code class="java">// 在文件最后添加一行RandomAccessFile af = new RandomAccessFile(outFile, &quot;rw&quot;);af.seek(af.length());af.writeBytes(&quot;\nadd this content at the end of file&quot;);</code></pre><h3 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h3><p>Scanner也可以用于文件的读取。但是不能用于文件的写入，并且这个工具主要设计用来创建编程语言的扫描器。（它不在java.io中，而在java.util中）</p><h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><p>标准I/O包括<strong>标准输入、标准输出和标准错误</strong>。</p><p>按照标准java提供了<strong>System.in、System.out和System.err</strong>。</p><p><strong>System.out</strong>和<strong>System.err</strong>都是PrintStream，但是<strong>System.in</strong>是一个未被包装过的InputStream。因此<strong>System.out</strong>和<strong>System.err</strong>可以直接使用（System.out.print()），而<strong>System.in</strong>需要装饰器包装，如BufferedReader（需要用InputStreamReader适配）等。（可以使用Scanner类）</p><h4 id="标准I-O重定向"><a href="#标准I-O重定向" class="headerlink" title="标准I/O重定向"></a>标准I/O重定向</h4><p>标准I/O原始的输入输出源是<strong>控制台console</strong>。</p><p>重定向函数：</p><table><thead><tr><th>标准输入System.in</th><th>标准输出System.out</th><th>标准错误System.err</th></tr></thead><tbody><tr><td>setIn(InputStream)</td><td>setOut(InputStream)</td><td>setErr(InputStream)</td></tr></tbody></table><p>⚠️<strong>注意</strong>：I/O重定向操作的字节流，而不是字符流，因此需要用到java1.0的I/O库。</p><h3 id="控制进程（不知道在干啥）"><a href="#控制进程（不知道在干啥）" class="headerlink" title="控制进程（不知道在干啥）"></a>控制进程（不知道在干啥）</h3><p>见书P551。实现了运行控制台指令，并输出在控制台上。</p><h3 id="新I-O"><a href="#新I-O" class="headerlink" title="新I/O"></a>新I/O</h3><p>JDK1.4的java.nio.*包中引入了新JavaI/O库，其目的在于提高速度。它也是面向字节的I/O。</p><p><strong>旧的I/O库也已经重新用nio实现过。因此可以不用显示的用nio编写代码。</strong></p><p>nio使用<strong>通道和缓存器</strong>提高了读写速度</p><p>####通道</p><p>旧I/O类库中有三个类被修改可以产生<strong>FileChannel</strong>，分别为<strong>FileInputStream</strong>、<strong>FileOutputStream</strong>和<strong>RandomAccessFile</strong>。</p><p>####缓存器</p><p>唯一直接与通道交互的缓存器是<strong>ByteBuffer</strong>。即FileChannel的write()方法和read()方法只接受<strong>ByteBuffer</strong>和<strong>ByteBuffer[]</strong>对象。</p><ul><li><p><strong>创建ByteBuffer</strong></p><ol><li><pre><code class="java">ByteBuffer buff = ByteBuffer.wrap(byte[]);</code></pre></li><li><pre><code class="java">ByteBuffer buff = ByteBuffer.allocate(BSIZE); // 单位为字节，会自动填充0// 往buff中添加数据buff.put(byte[]);buff.put(ByteBuffer);channel.write(buff);</code></pre></li></ol></li><li><p><strong>获取ByteBuffer中的数据</strong></p><ol><li><pre><code class="java">// buff.get()返回的是byte对象while (buff.hasRemaining()) {    System.out.println((char) buff.get());}</code></pre></li><li><pre><code class="java">// 使用解码器，如中文从字节转换到字符等，用jvm默认的编码方式会产生乱码，需要用UTF_8或其他uniCode编码方式解码。// CharBuffer的存储单位为2字节CharBuffer decode = StandardCharsets.UTF_8.decode(buff);</code></pre></li></ol></li><li><p><strong>基本类型转换</strong></p><p>{primitive type}Buffer buffer = byteBufferObject.as{primitive type}Buffer()</p><p>不同类型的存储单位不同，存储单位与相应基本类型长度相同。如char为2字节，int为4字节，double为8字节。</p></li><li><p><strong>字节存放顺序</strong></p><p>分为大端和小端（高位优先和低位优先），ByteBuffer默认为小端。</p><pre><code class="java">ByteBuffer buff = ByteBuffer.allocate(BSIZE);buff.order(ByteOrder.BIG_ENDIAN); //大端buff.order(ByteOrder.LITTLE_ENDIAN); //小端</code></pre></li><li><p><strong>与索引相关的方法</strong></p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>capacity()</td><td>返回缓存区容量</td></tr><tr><td>clear()</td><td>清空缓存区。position-&gt;0, limit-&gt;capacity</td></tr><tr><td>flip()</td><td>用于准备从缓存区中读取数据。limit-&gt;position, position-&gt;0</td></tr><tr><td>limit()</td><td>返回limit的值，limit主要影响remaining()返回的值</td></tr><tr><td>limit(int lim)</td><td>设置limit的值</td></tr><tr><td>mark()</td><td>将mark设置为position</td></tr><tr><td>reset()</td><td>将position设置为mark</td></tr><tr><td>position()</td><td>返回position的值</td></tr><tr><td>position(int pos)</td><td>设置position的值</td></tr><tr><td>remaining()</td><td>返回(limit-position)</td></tr><tr><td>hasRemaining()</td><td>返回(position &lt; limit)</td></tr><tr><td>rewind()</td><td>设置position为0</td></tr><tr><td>get()/get(int i)</td><td>get()会使position加1</td></tr><tr><td>put(byte[])</td><td>会使position增加放入的byte数，若超过capacity，则position为capacity</td></tr></tbody></table></li></ul><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>用来修改大尺寸文件，速度很快。P563</p><h3 id="文件加锁"><a href="#文件加锁" class="headerlink" title="文件加锁"></a>文件加锁</h3><p>P566</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>P568 gzip和zip</p><h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h3><p>P571 标记接口Serializable</p><p>static值不会被自动序列化</p><h1 id="第十九章-枚举类型"><a href="#第十九章-枚举类型" class="headerlink" title="第十九章 枚举类型"></a>第十九章 枚举类型</h1><h3 id="基本enum特性"><a href="#基本enum特性" class="headerlink" title="基本enum特性"></a>基本enum特性</h3><ul><li><p>每一个枚举类都继承了java.lang.Enum类</p></li><li><p><strong>每一个enum的具体枚举对象都像是这个枚举类的一个独特的子类（但其实是一个static final实例），也就是说每次调用了一个枚举（EnumClass.XXX）就像是new了一个此枚举类的实例。因此构造函数也只能在内部被使用。</strong></p></li><li><p>可以使用==来比较enum实例</p></li><li><p>用反射的方式也可以得到枚举类实例</p><pre><code class="java">Enmu.valueOf(EnmuClass.class, String str)</code></pre></li><li><p>enum类除了不能继承之外，我们可以把它看作一个常规的类，可以添加构造函数和方法。但是必须先定义enum实例，并在最后添加一个分号。</p></li><li><p>switch语句中也可以使用enum类型，而且在case语句中不需要使用一个enum类型来修饰enum实例。</p></li><li><p>values()和ValueOf(String)两个方法是编译器添加的静态方法，原来Enum中valueOf(Class&lt;T&gt; enumType, String name) 和它是两个不同的方法。</p><p>所以将enum实例向上转型为Enum将不能使用values()了，不过Class中有一个getEnumConstants()方法也可以获得所有的enum实例。</p></li></ul><h3 id="EnumSet和EnumMap"><a href="#EnumSet和EnumMap" class="headerlink" title="EnumSet和EnumMap"></a>EnumSet和EnumMap</h3><p>速度快，枚举类就用它们。</p><p>EnumSet需要用<code>EnumSet.of()</code>或者<code>EnumSet.noneOf()</code>来初始化。它本身是一个abstract class。</p><h3 id="关于常量相关的方法（constant-specific-methods）"><a href="#关于常量相关的方法（constant-specific-methods）" class="headerlink" title="关于常量相关的方法（constant-specific methods）"></a>关于常量相关的方法（constant-specific methods）</h3><p>需要先定义一个abstract方法，然后每个enum实例可以实现该抽象方法。</p><p>也可以覆盖enum类中定义的方法，如下面的函数f()。</p><pre><code class="java">enum Test {    A(&quot;a&quot;){        @Override        void behavior() {            System.out.println(&quot;i am a&quot;);        }        @Override        void f() {            behavior();        }    }, B(&quot;b&quot;) {        @Override        void behavior() {            System.out.println(&quot;i am b&quot;);        }    }, C(&quot;c&quot;) {        @Override        void behavior() {            System.out.println(&quot;i am c&quot;);        }    };    String lowCase;    abstract void behavior();    void f() {        System.out.println(lowCase);    }    Test(String lowCase) {        this.lowCase = lowCase;    }}</code></pre><p>用这个方式可以实现<strong>命令模式P604</strong>、<strong>责任链模式P606</strong>和<strong>状态模式P609</strong></p><p>###多路分发</p><p>在使用a.plus(b)时，a和b的具体类型都不知道。</p><p>解决方法为<strong>二路分发</strong>：在调用a.plus()时第一次分发，在方法体内部可以得到a的类型，于是在方法体中再次调用b.method(this)完成第二次分发，这时a和b的类型都可以得到。</p><p>这样的解决方法会使代码更加优雅（用反射也可以完成，就是代码难看一点）</p><h1 id="第二十章-注解"><a href="#第二十章-注解" class="headerlink" title="第二十章 注解"></a>第二十章 注解</h1><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><table><thead><tr><th>元注解</th><th>含义</th></tr></thead><tbody><tr><td>@Target</td><td>表示该注解可以用于什么地方。如ElementType.FIELD…</td></tr><tr><td>@Retention</td><td>表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数有SOURCE、CLASS和RUNTIME。一般需要用反射在运行时获取注解都需要使用RUNTIME。</td></tr><tr><td>@Document</td><td>将此注解包含在Javadoc中</td></tr><tr><td>@Inherited</td><td>允许子类继承父类中的注解</td></tr></tbody></table><h3 id="默认值限制"><a href="#默认值限制" class="headerlink" title="默认值限制"></a>默认值限制</h3><p>default可以为注解元素添加默认值，默认值不允许为null。</p><h3 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h3><p>在注解中定义了名为value的元素，并且在应用该注解的时候如果该元素是唯一需要赋值的一个元素，那么此时无需使用名-值对的这种语法，而只需要在括号内给出value元素需要的值即可。</p><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>注解只是一个标注，没有处理器的注解就如同注释。</p><p>一般在处理器中使用反射机制获取注解信息。</p><p>####注解处理工具apt</p><p>本书中所说的api在SE7之后已经被废弃。</p><p><strong>Note</strong>: The <code>apt</code> tool and its associated API contaiined in the pakcage <code>com.sun.mirror</code> have been deprecated since Java SE 7. Use the options available in the <code>javac</code> tool and the APIs contained in the packages <code>javax.annotation.processing</code> and <code>javax.lang.model</code> to process annotations.</p><p><a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101" target="_blank" rel="noopener">使用<em>JavaSE</em>中的<em>javac</em>和<em>javax.annotation.processing</em>进行注解处理</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习中遇到的问题</title>
    <link href="undefined2019/10/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>2019/10/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Logistic-regression"><a href="#Logistic-regression" class="headerlink" title="Logistic regression"></a>Logistic regression</h1><p><strong>常用的数据集预处理方法</strong></p><ul><li>找出数据集的维度和形状（m_train, m_test, num_px,….）</li><li>用reshape方法将数据集的每一个样本化为一个列向量（num_px * numpx * 3, 1）</li><li>标准化数据（n/(MAX - MIN)）</li></ul><p><strong>注意</strong></p><p>图片处理的scipy.imread和imresize已经被抛弃，用matplotlib.pyplot.imread或者PLT.Image.open代替imread。用Image对象image.resize代替imresize。</p><p><strong>reshape的坑</strong></p><pre><code class="python">train_x_flatten = train_x_orig.reshape(-1, train_x_orig.shape[0])train_x_flatten2 = train_x_orig.reshape(train_x_orig.shape[0], -1).T</code></pre><p>两者不相等，要了解其中含义</p><p>#He initialization</p><p>​    This function is similar to the previous initialize_parameters_random(…). The only difference is that instead of multiplying np.random.randn(..,..) by 10, you will multiply it by <strong>sqrt(2./layers_dims[l-1])</strong> , which is what He initialization recommends for layers with a ReLU activation.</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在用Maven搭建SpringMVC项目时出现的问题</title>
    <link href="undefined2019/10/13/%E5%9C%A8%E7%94%A8Maven%E6%90%AD%E5%BB%BASpringMVC%E9%A1%B9%E7%9B%AE%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>2019/10/13/%E5%9C%A8%E7%94%A8Maven%E6%90%AD%E5%BB%BASpringMVC%E9%A1%B9%E7%9B%AE%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>IDE: IntelliJ IDEA 2019.2.3专业版<br>系统：MacOS<br>JDK：1.8</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Maven项目没有src文件夹"><a href="#Maven项目没有src文件夹" class="headerlink" title="Maven项目没有src文件夹"></a>Maven项目没有src文件夹</h2><p>打开Perference设置，在Build, Execution, Deployment-&gt;Build Tools-&gt;Maven-&gt;Runner的VM Options中添加<strong>-DarchetypeCatalog=internal</strong></p><h2 id="项目Add-Framework-Support中无法添加SpringMVC框架"><a href="#项目Add-Framework-Support中无法添加SpringMVC框架" class="headerlink" title="项目Add Framework Support中无法添加SpringMVC框架"></a>项目Add Framework Support中无法添加SpringMVC框架</h2><ul><li>先在Project Structure的Modules中删除Spring框架，重新添加SpringMVC框架</li><li>如果还是没有，打开Perference设置，在Plugins中勾选启用SpringMVC</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回顾UML</title>
    <link href="undefined2019/10/10/%E5%9B%9E%E9%A1%BEUML/"/>
    <url>2019/10/10/%E5%9B%9E%E9%A1%BEUML/</url>
    
    <content type="html"><![CDATA[<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><img src="https://i.natfrp.com/9fdfaefc97ad92394e08125d4ae04fae.png" srcset="/img/loading.gif" alt="class" style="zoom:50%;"><h2 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h2><ol><li><p><strong>Inheritance|继承</strong>：字面意义</p><pre><code class="c++">class CMyDoc : public CDocument{    private:      CObList myList;};</code></pre><img src="https://i.natfrp.com/40270b82a208cdb66a47d376cf7105d9.png" srcset="/img/loading.gif" alt="inheritance" style="zoom:50%;"></li><li><p><strong>Composition|组成</strong>：一个类包含另一个类，部分和整体的生命周期一致。分为composition by value和composition by reference。（下例为composition by value）</p><pre><code class="c++">class CMyDoc : public CDocument{    private:        CObList myList;};</code></pre><img src="https://i.natfrp.com/5bebb222646084471eb19e9f1f0bb289.png" srcset="/img/loading.gif" alt="composition" style="zoom:50%;"></li><li><p><strong>Aggregation|聚合</strong>：composition的一种，即composition by reference。比composition by value的关系弱。以指针的形式表现，是一种弱的拥有关系。可以在需要的时候为指针分配空间，不需要的时候释放。部分与整体生命周期不一致。</p><pre><code>class CMyDoc : public CDocument{    private:        CObList* myList;};</code></pre><p><img src="https://i.natfrp.com/4964eaacdd9614b0dc0bcde4f91f437b.png" srcset="/img/loading.gif" alt="aggregation"></p></li><li><p><strong>Association|关联</strong>：一个类必须知道另一个类的成员和变量。若A-&gt;B，则A中存在classB的实例。关联包括聚合和组成。有双向和单项两种。</p><p><img src="https://i.natfrp.com/95e8b899324878203d7337860a187de6.png" srcset="/img/loading.gif" alt="img"></p></li></ol><p>（待续）</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="undefined2019/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>2019/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h1><ul><li><p><strong>定义</strong><br>首先定义一个算法骨干，推迟其中一些步骤使它们在<strong>子类</strong>中获得定义。即这些步骤在父亲类中是抽象的，需要在子类中实现。Template Method使得子类可以重新定义算法中的某些步骤，而不需要改变算法的架构（骨干）。<br>我们平时使用的许多接口都采用了这种方法。</p></li><li><p><strong>类图表示</strong></p><p><img src="/img/backup/TemplateMethod.png" srcset="/img/loading.gif" alt="TemplateMethod"></p></li><li><p><strong>示例</strong></p><ul><li><p>类图：</p><img src="https://i.natfrp.com/8057cae3fc6aeaed54a45e8a787338c8.png" srcset="/img/loading.gif" alt="TemplateMethodSample" style="zoom:50%;"></li><li><p>java代码：</p><pre><code class="java">public class Main {    public static void main(String[] args) {        Generalization algorithm = new Realization();        algorithm.findSolution();    }}abstract class Generalization{    // 定义一个算法骨干    public void findSolution(){        stepOne();        stepTwo();        stepThr();        stepFor();    }    protected void stepOne(){        System.out.println(&quot;Generalization: stepOne&quot;);    }    // 存在两个为实现的步骤，将在子类中实现    abstract protected void stepTwo();    abstract protected void stepThr();    protected void stepFor(){        System.out.println(&quot;Generalization: stepFor&quot;);    }}abstract class Specialization extends Generalization{    // 实现了算法的stepThr，stepThr中也存在抽象方法，因此stepThr也算作一个算法骨干    @Override    protected void stepThr(){        step3_1();        step3_2();        step3_3();    }    protected void step3_1(){        System.out.println(&quot;Specialization: step3_1&quot;);    }    // stepThr的step3_2将在子类中实现    abstract protected void step3_2();    protected void step3_3(){        System.out.println(&quot;Specialization: step3_2&quot;);    }}class Realization extends Specialization{    @Override    protected void stepTwo() {        System.out.println(&quot;Realization: stepTwo&quot;);    }    @Override    protected void step3_2() {        System.out.println(&quot;Realization: step3_2&quot;);    }    @Override    protected void stepFor() {        super.stepFor();        System.out.println(&quot;Realization: stepFor&quot;);    }}</code></pre></li><li><p>输出:</p><pre>Generalization: stepOneRealization: stepTwoSpecialization: step3_1Realization: step3_2Specialization: step3_2Generalization: stepForRealization: stepFor</pre></li></ul></li></ul><h1 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h1><ul><li><p><strong>定义</strong></p><p>首先定义一个族系算法（a family of algorithms），然后封装其中每一个算法成为类class，使得它们可以被交换使用。</p><p>Strategy可以使算法添加，删除不影响客户。</p></li><li><p><strong>类图表示</strong></p><p><img src="/img/backup/Strategy.png" srcset="/img/loading.gif" alt="Strategy"></p></li><li><p><strong>示例</strong></p><ul><li><p>类图</p><p><img src="https://i.natfrp.com/bbc90d5c49dcd2906e03115bc815c536.png" srcset="/img/loading.gif" alt="StrategySample"></p></li><li><p>c++代码</p><p>首先定义一个族系的父类Strategy，在这个例子中算法家族做的是定义一个文本格式。format()函数是一个Template Method，其中的步骤justify()需要子类实现。</p><p><strong>由于Strategy需要实现算法抽换。因此，可以看出Strategy这一设计模式大多数情况下都需要用到Template Method，抽换对象是最后实现所有步骤的子类，而这样的子类将会有很多个，每一个都实现了不同的功能。</strong></p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstring&gt;using namespace std;class Strategy{public:    Strategy(int width):_width(width){}    void format(){        char line[80], word[30];        ifstream inFile(&quot;text.txt&quot;, ios::in);        line[0] = &#39;\0&#39;;        inFile &gt;&gt; word;        strcat(line, word);        while (inFile &gt;&gt; word){            if (strlen(line) + strlen(word) + 1 &gt; _width) {                justufy(line);            }            else{                strcat(line, &quot; &quot;);            }            strcat(line, word);        }        justufy(line);    }protected:    int _width;private:    virtual void justufy(char* line) = 0;};</code></pre><p>LeftStrategy为家族中的一员，实现左对齐。</p><pre><code class="c++">class LeftStragety: public Strategy{public:    LeftStragety(int width): Strategy(width){}private:    void justify(char *line) override{        cout &lt;&lt; line &lt;&lt; endl;        line[0] = &#39;\0&#39;;    }};</code></pre><p>RightStrategy为家族中的一员，实现右对齐。</p><pre><code class="c++">class RightStragety: public Strategy{public:    RightStragety(int width): Strategy(width){}private:    void justify(char *line) override{        char buf[80];        int offset = _width - strlen(line);        memset(buf, &#39; &#39;, 80);        strcpy(&amp;(buf[offset]), line);        cout &lt;&lt; buf &lt;&lt; endl;        line[0] = &#39;\0&#39;;    }};</code></pre><p>CenterStrategy为家族中的一员，实现居中。</p><pre><code class="c++">class CenterStragety: public Strategy{public:    CenterStragety(int width): Strategy(width){}private:    void justify(char *line) override{        char buf[80];        int offset = (_width - strlen(line)) / 2;        memset(buf, &#39; &#39;, 80);        strcpy(&amp;(buf[offset]), line);        cout &lt;&lt; buf &lt;&lt; endl;        line[0] = &#39;\0&#39;;    }};</code></pre><p>以上是整个族系算法。接下来还需要一个类实现算法抽换和执行。</p><p>setStrategy()实现抽换，doit()执行。</p><p>(也可以不构造此类，让用户自己进行算法的抽换)</p><pre><code class="c++">class Test{public:    enum StrategyType{        Undefined, Left, Right, Center    };    Test(): _strategy(NULL){}    void setStrategy(int type, int width){        if (_strategy != NULL) {            delete _strategy;        }        switch (type) {            case Left:                _strategy = new LeftStragety(width);                break;            case Right:                _strategy = new RightStragety(width);                    break;            case Center:                _strategy = new CenterStragety(width);                    break;            default:                break;        }    }    void doit(){        _strategy-&gt;format();    }private:Strategy* _strategy;    int a;};</code></pre><p>main()函数</p><pre><code class="c++">int main(int argc, const char * argv[]) {    Test _test;    int type, width;    cout &lt;&lt; &quot;Exit(0) Left(1) Right(2) Center(3): &quot;;    cin &gt;&gt; type;    while (type) {        cout &lt;&lt; &quot;width: &quot;;        cin &gt;&gt; width;        _test.setStrategy(type, width);        _test.doit();        cout &lt;&lt; &quot;Exit(0) Left(1) Right(2) Center(3): &quot;;        cin &gt;&gt; type;    }}</code></pre><p>若之后要加入在家族中加入一个新成员（这里指新的格式），只要在Test类的setStrategy（抽换算法）中添加一个新的选择即可。</p></li></ul></li></ul><h1 id="Observer-publish-subscribe"><a href="#Observer-publish-subscribe" class="headerlink" title="Observer/publish-subscribe"></a>Observer/publish-subscribe</h1><ul><li><p><strong>定义</strong></p><p>在objects之间定义“一对多”的依存关系，当一个object发生改变时，其他依存于它的objects们也会被通知并更新。</p></li><li><p><strong>类图表示</strong></p><p>java标准库：<br><img src="/img/backup/Observer.png" srcset="/img/loading.gif" alt="Observer"></p></li><li><p><strong>示例</strong></p><ul><li><p>类图</p><p><img src="https://i.natfrp.com/6cafc22f5ae227f56111092958fdae27.png" srcset="/img/loading.gif" alt="ObserverSample"></p></li><li><p>java代码</p><p><strong>java中已经封装了Observer和Observable以供使用，这里为了进一步掌握这个设计模式，重新实现了Observer设计模式。</strong></p><p>首先定一个Observe接口和Subject主体用于通知全部订阅了的观察者（对应标准库中的Observable）</p><pre><code class="java">interface Observer{    void update(int value);}class Subject{    int m_value;    List&lt;Observer&gt; m_views;    Subject(){        m_views = new ArrayList&lt;&gt;();    }    public void addObserver(Observer observe){        m_views.add(observe);    }    private void notifyChanges(){        for (Observer observe: m_views){            observe.update(m_value);        }    }    public void set_value(int value){        m_value = value;        notifyChanges();    }}</code></pre><p>实现了继承Observer的两个观察者</p><pre><code class="java">class DivObserve implements Observer{    private int m_div;    DivObserve(int div){        m_div = div;    }    @Override    public void update(int value) {        System.out.println(value+&quot; div &quot;+m_div+&quot; = &quot;+(value / m_div));    }}class ModObserve implements Observer{    private int m_mod;    ModObserve(int mod){        m_mod = mod;    }    @Override    public void update(int value) {        System.out.println(value+&quot; mod &quot;+m_mod+&quot; = &quot;+(value % m_mod));    }}</code></pre><p>main()函数在创建新观察者后，调用addObserver()函数订阅（依赖）subject主体。</p><pre><code class="java">public class Main {    public static void main(String[] args) {        Subject subject = new Subject();        DivObserve div1 = new DivObserve(4);        DivObserve div2 = new DivObserve(3);        ModObserve mod1 = new ModObserve(3);        subject.addObserver(div1);        subject.addObserver(div2);        subject.addObserver(mod1);        subject.set_value(14);    }}</code></pre></li><li><p>输出</p><pre>14 div 4 = 314 div 3 = 414 mod 3 = 2</pre></li></ul></li></ul><h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><ul><li><p><strong>定义</strong></p><p>提供一种方法可以循环访问一个聚合物（List，Vector等）而无需显露聚合物的底部表述。</p><p>比如java中遍历不同的聚合物需要知道不同聚合物获得元素的方法。</p></li><li><p><strong>类图表示</strong></p><p><img src="/img/backup/Iteration.png" srcset="/img/loading.gif" alt="Iteration"><br>java标准库：<br><img src="/img/backup/Iteration1.png" srcset="/img/loading.gif" alt="Iteration1"></p></li><li><p><strong>为什么要用Iteration来遍历</strong></p><ul><li><p>Iteration可以提供一种统一的方法访问一个聚合物，客户无需知道聚合物的具体用法。</p><p><code>for(Iterator it = aggregation.iterater(); it.hasNext(); )</code></p><p> <code>{ ... }</code></p></li><li><p>用Iteration在改变聚合物的种类时，可以减少对代码的修改（无需修改循环部分），符合OCP的设计准则。</p></li></ul></li></ul><h1 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h1><ul><li><p><strong>定义</strong></p><p>单例模式，确保某个class只能生成唯一一个实体。使用private修饰的构造函数实现。</p></li><li><p><strong>类图表示</strong></p><p>Singleton的实现方法有很多种，这里只介绍比较实用的一种。<br><img src="/img/backup/Singleton.png" srcset="/img/loading.gif" alt="Singleton"></p></li><li><p><strong>示例</strong></p><ul><li><p>java代码</p><pre><code class="java">public class SingleObject {   //创建 SingleObject 的一个对象   private static SingleObject instance = new SingleObject();   //让构造函数为 private，这样该类就不会被实例化   private SingleObject(){}   //获取唯一可用的对象   public static SingleObject getInstance(){      return instance;   }   public void showMessage(){      System.out.println(&quot;Hello World!&quot;);   }}</code></pre></li></ul></li></ul><h1 id="FlyWeight"><a href="#FlyWeight" class="headerlink" title="FlyWeight"></a>FlyWeight</h1><p>参考：<a href="https://sourcemaking.com/design_patterns" target="_blank" rel="noopener">Design Patterns</a></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回顾html</title>
    <link href="undefined2019/10/08/%E5%9B%9E%E9%A1%BEhtml/"/>
    <url>2019/10/08/%E5%9B%9E%E9%A1%BEhtml/</url>
    
    <content type="html"><![CDATA[<p>对html语言进行了回顾和再次学习。</p><h2 id="html样式"><a href="#html样式" class="headerlink" title="html样式"></a>html样式</h2><p>一些标签和属性都用html中的style属性所代替了。</p><h4 id="被抛弃的标签和属性"><a href="#被抛弃的标签和属性" class="headerlink" title="被抛弃的标签和属性"></a>被抛弃的标签和属性</h4><table><thead><tr><th>标签/属性</th><th>描述</th></tr></thead><tbody><tr><td>&lt;center&gt;</td><td>定义居中的内容</td></tr><tr><td>&lt;font&gt;和&lt;basefont&gt;</td><td>定义HTML字体</td></tr><tr><td>&lt;s&gt;和&lt;strike&gt;(使用&lt;del&gt;代替)</td><td>定义删除线文本</td></tr><tr><td>&lt;u&gt;(使用样式&lt;ins&gt;代替)</td><td>定义下划线文本</td></tr><tr><td>align</td><td>定义文本对齐方式</td></tr><tr><td>bgcolor/color</td><td>定义背景/文本颜色</td></tr></tbody></table><h2 id="html折行"><a href="#html折行" class="headerlink" title="html折行"></a>html折行</h2><p>使用&lt;br /&gt;标签:</p><pre><code class="html">&lt;p&gt;This is&lt;br /&gt;a para&lt;br /&gt;graph with line breaks&lt;/p&gt;</code></pre><h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><table><thead><tr><th>标签</th><th>效果</th></tr></thead><tbody><tr><td>&lt;p&gt;</td><td>正常</td></tr><tr><td>&lt;big&gt;</td><td><big>大号</big></td></tr><tr><td>&lt;em&gt;</td><td><em>着重</em></td></tr><tr><td>&lt;i&gt;</td><td><i>斜体</i></td></tr><tr><td>&lt;small&gt;</td><td><small>小号</small></td></tr><tr><td>&lt;b&gt;</td><td><b>粗体</b></td></tr><tr><td>&lt;strong&gt;</td><td><strong>加强语气</strong></td></tr><tr><td>&lt;sub&gt;</td><td>正常<sub>下标</sub></td></tr><tr><td>&lt;sup&gt;</td><td>正常<sup>上标</sup></td></tr><tr><td>&lt;ins&gt;</td><td><ins>插入</ins></td></tr><tr><td>&lt;del&gt;</td><td><del>删除</del></td></tr></tbody></table><h4 id="“计算机输出“标签"><a href="#“计算机输出“标签" class="headerlink" title="“计算机输出“标签"></a>“计算机输出“标签</h4><table><thead><tr><th>标签</th><th>效果</th></tr></thead><tbody><tr><td>&lt;code&gt;</td><td><code>prinf()</code></td></tr><tr><td>&lt;kbd&gt;</td><td><kbd>space</kbd></td></tr><tr><td>&lt;pre&gt;</td><td><pre>预格式文本</pre></td></tr><tr><td>&lt;var&gt;</td><td><var>变量</var></td></tr><tr><td>&lt;tt&gt;</td><td><tt>打字机格式</tt></td></tr></tbody></table><p>&lt;code&gt; 元素不保留多余的空格和折行，用&lt;pre&gt;解决。</p><pre><code>&lt;code&gt;&lt;pre&gt;var person = {    firstName:&quot;Bill&quot;,    lastName:&quot;Gates&quot;,    age:50,    eyeColor:&quot;blue&quot;}&lt;/pre&gt;&lt;/code&gt;</code></pre><p>效果：</p><code><pre>var person = {    firstName:"Bill",    lastName:"Gates",    age:50,    eyeColor:"blue"}</pre></code><h4 id="引用和术语定义"><a href="#引用和术语定义" class="headerlink" title="引用和术语定义"></a>引用和术语定义</h4><table><thead><tr><th>标签</th><th>效果</th></tr></thead><tbody><tr><td>&lt;abbr&gt;(缩写)</td><td><abbr title="etcetera">etc.</abbr></td></tr><tr><td>&lt;acronym&gt;(首字母缩写)</td><td><acronym title="World Wide Web">WWW</acronym></td></tr><tr><td>&lt;q&gt;</td><td><q>引用，周围有引号</q></td></tr><tr><td>&lt;bdo&gt;(dir=”rtl”)</td><td><bdo dir="rtl">Reverse</bdo></td></tr><tr><td>&lt;dfn&gt;</td><td><p><dfn title="World Health Organization">WHO</dfn> 成立于 1948 年。</p></td></tr></tbody></table><h2 id="HTML-链接-target-属性"><a href="#HTML-链接-target-属性" class="headerlink" title="HTML 链接 - target 属性"></a>HTML 链接 - target 属性</h2><p>下面的这行会在新窗口打开文档：</p><pre><code>&lt;a href=&quot;http://www.w3school.com.cn/&quot; target=&quot;_blank&quot;&gt;Visit W3School!&lt;/a&gt;</code></pre><h2 id="HTML-链接-name-属性"><a href="#HTML-链接-name-属性" class="headerlink" title="HTML 链接 - name 属性"></a>HTML 链接 - name 属性</h2><p>首先，我们在 HTML 文档中对锚进行命名（创建一个书签）：</p><pre><code>&lt;a name=&quot;tips&quot;&gt;基本的注意事项 - 有用的提示&lt;/a&gt;</code></pre><p>然后，我们在同一个文档中创建指向该锚的链接：</p><pre><code>&lt;a href=&quot;#tips&quot;&gt;有用的提示&lt;/a&gt;</code></pre><p>您也可以在其他页面中创建指向该锚的链接：</p><pre><code>&lt;a href=&quot;http://www.w3school.com.cn/html/html_links.asp#tips&quot;&gt;有用的提示&lt;/a&gt;</code></pre><h2 id="div与span的区别"><a href="#div与span的区别" class="headerlink" title="div与span的区别"></a>div与span的区别</h2><p>div是块级元素，可以用于布局。<br>span是内联元素，多用于为部分文本设置不一样的样式。</p><h2 id="HTML文件路径"><a href="#HTML文件路径" class="headerlink" title="HTML文件路径"></a>HTML文件路径</h2><table><thead><tr><th align="left">路径</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">&lt;img src=”picture.jpg”&gt;</td><td align="left">picture.jpg 位于与当前网页相同的文件夹</td></tr><tr><td align="left">&lt;img src=”images/picture.jpg”&gt;</td><td align="left">picture.jpg 位于当前文件夹的 images 文件夹中</td></tr><tr><td align="left">&lt;img src=”/images/picture.jpg”&gt;</td><td align="left">picture.jpg 当前站点根目录的 images 文件夹中</td></tr><tr><td align="left">&lt;img src=”../picture.jpg”&gt;</td><td align="left">picture.jpg 位于当前文件夹的上一级文件夹中</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>