<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深度学习中遇到的问题</title>
    <link href="undefined2019/10/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>2019/10/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Logistic-regression"><a href="#Logistic-regression" class="headerlink" title="Logistic regression"></a>Logistic regression</h1><p><strong>常用的数据集预处理方法</strong></p><ul><li>找出数据集的维度和形状（m_train, m_test, num_px,….）</li><li>用reshape方法将数据集的每一个样本化为一个列向量（num_px * numpx * 3, 1）</li><li>标准化数据（n/(MAX - MIN)）</li></ul><p><strong>注意</strong></p><p>图片处理的scipy.imread和imresize已经被抛弃，用matplotlib.pyplot.imread或者PLT.Image.open代替imread。用Image对象image.resize代替imresize</p><p><strong>reshape的坑</strong></p><pre><code class="python">train_x_flatten = train_x_orig.reshape(-1, train_x_orig.shape[0])train_x_flatten2 = train_x_orig.reshape(train_x_orig.shape[0], -1).T</code></pre><p>两者不相等，要了解其中含义</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在用Maven搭建SpringMVC项目时出现的问题</title>
    <link href="undefined2019/10/13/%E5%9C%A8%E7%94%A8Maven%E6%90%AD%E5%BB%BASpringMVC%E9%A1%B9%E7%9B%AE%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>2019/10/13/%E5%9C%A8%E7%94%A8Maven%E6%90%AD%E5%BB%BASpringMVC%E9%A1%B9%E7%9B%AE%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>IDE: IntelliJ IDEA 2019.2.3专业版<br>系统：MacOS<br>JDK：1.8</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Maven项目没有src文件夹"><a href="#Maven项目没有src文件夹" class="headerlink" title="Maven项目没有src文件夹"></a>Maven项目没有src文件夹</h2><p>打开Perference设置，在Build, Execution, Deployment-&gt;Build Tools-&gt;Maven-&gt;Runner的VM Options中添加<strong>-DarchetypeCatalog=internal</strong></p><h2 id="项目Add-Framework-Support中无法添加SpringMVC框架"><a href="#项目Add-Framework-Support中无法添加SpringMVC框架" class="headerlink" title="项目Add Framework Support中无法添加SpringMVC框架"></a>项目Add Framework Support中无法添加SpringMVC框架</h2><ul><li>先在Project Structure的Modules中删除Spring框架，重新添加SpringMVC框架</li><li>如果还是没有，打开Perference设置，在Plugins中勾选启用SpringMVC</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回顾UML</title>
    <link href="undefined2019/10/10/%E5%9B%9E%E9%A1%BEUML/"/>
    <url>2019/10/10/%E5%9B%9E%E9%A1%BEUML/</url>
    
    <content type="html"><![CDATA[<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><img src="https://i.natfrp.com/9fdfaefc97ad92394e08125d4ae04fae.png" srcset="/img/loading.gif" alt="class" style="zoom:50%;"><h2 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h2><ol><li><p><strong>Inheritance|继承</strong>：字面意义</p><pre><code class="c++">class CMyDoc : public CDocument{    private:      CObList myList;};</code></pre><img src="https://i.natfrp.com/40270b82a208cdb66a47d376cf7105d9.png" srcset="/img/loading.gif" alt="inheritance" style="zoom:50%;"></li><li><p><strong>Composition|组成</strong>：一个类包含另一个类，部分和整体的生命周期一致。分为composition by value和composition by reference。（下例为composition by value）</p><pre><code class="c++">class CMyDoc : public CDocument{    private:        CObList myList;};</code></pre><img src="https://i.natfrp.com/5bebb222646084471eb19e9f1f0bb289.png" srcset="/img/loading.gif" alt="composition" style="zoom:50%;"></li><li><p><strong>Aggregation|聚合</strong>：composition的一种，即composition by reference。比composition by value的关系弱。以指针的形式表现，是一种弱的拥有关系。可以在需要的时候为指针分配空间，不需要的时候释放。部分与整体生命周期不一致。</p><pre><code>class CMyDoc : public CDocument{    private:        CObList* myList;};</code></pre><p><img src="https://i.natfrp.com/4964eaacdd9614b0dc0bcde4f91f437b.png" srcset="/img/loading.gif" alt="aggregation"></p></li><li><p><strong>Association|关联</strong>：一个类必须知道另一个类的成员和变量。若A-&gt;B，则A中存在classB的实例。关联包括聚合和组成。有双向和单项两种。</p><p><img src="https://i.natfrp.com/95e8b899324878203d7337860a187de6.png" srcset="/img/loading.gif" alt="img"></p></li></ol><p>（待续）</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="undefined2019/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>2019/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h1><ul><li><p><strong>定义</strong><br>首先定义一个算法骨干，推迟其中一些步骤使它们在<strong>子类</strong>中获得定义。即这些步骤在父亲类中是抽象的，需要在子类中实现。Template Method使得子类可以重新定义算法中的某些步骤，而不需要改变算法的架构（骨干）。<br>我们平时使用的许多接口都采用了这种方法。</p></li><li><p><strong>示例</strong></p><ul><li><p>类图：</p><img src="https://i.natfrp.com/8057cae3fc6aeaed54a45e8a787338c8.png" srcset="/img/loading.gif" alt="TemplateMethod" style="zoom:50%;"></li><li><p>java代码：</p><pre><code class="java">public class Main {    public static void main(String[] args) {        Generalization algorithm = new Realization();        algorithm.findSolution();    }}abstract class Generalization{    // 定义一个算法骨干    public void findSolution(){        stepOne();        stepTwo();        stepThr();        stepFor();    }    protected void stepOne(){        System.out.println(&quot;Generalization: stepOne&quot;);    }    // 存在两个为实现的步骤，将在子类中实现    abstract protected void stepTwo();    abstract protected void stepThr();    protected void stepFor(){        System.out.println(&quot;Generalization: stepFor&quot;);    }}abstract class Specialization extends Generalization{    // 实现了算法的stepThr，stepThr中也存在抽象方法，因此stepThr也算作一个算法骨干    @Override    protected void stepThr(){        step3_1();        step3_2();        step3_3();    }    protected void step3_1(){        System.out.println(&quot;Specialization: step3_1&quot;);    }    // stepThr的step3_2将在子类中实现    abstract protected void step3_2();    protected void step3_3(){        System.out.println(&quot;Specialization: step3_2&quot;);    }}class Realization extends Specialization{    @Override    protected void stepTwo() {        System.out.println(&quot;Realization: stepTwo&quot;);    }    @Override    protected void step3_2() {        System.out.println(&quot;Realization: step3_2&quot;);    }    @Override    protected void stepFor() {        super.stepFor();        System.out.println(&quot;Realization: stepFor&quot;);    }}</code></pre></li></ul></li></ul><ul><li><p>输出:</p><pre>Generalization: stepOneRealization: stepTwoSpecialization: step3_1Realization: step3_2Specialization: step3_2Generalization: stepForRealization: stepFor</pre></li></ul><h1 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h1><ul><li><p><strong>定义</strong></p><p>首先定义一个族系算法（a family of algorithms），然后封装其中每一个算法成为类class，使得它们可以被交换使用。</p><p>Strategy可以使算法添加，删除不影响客户。</p></li><li><p><strong>示例</strong></p><ul><li><p>类图</p><p><img src="https://i.natfrp.com/bbc90d5c49dcd2906e03115bc815c536.png" srcset="/img/loading.gif" alt="Strategy"></p></li><li><p>c++代码</p><p>首先定义一个族系的父类Strategy，在这个例子中算法家族做的是定义一个文本格式。format()函数是一个Template Method，其中的步骤justify()需要子类实现。</p><p><strong>由于Strategy需要实现算法抽换。因此，可以看出Strategy这一设计模式大多数情况下都需要用到Template Method，抽换对象是最后实现所有步骤的子类，而这样的子类将会有很多个，每一个都实现了不同的功能。</strong></p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstring&gt;using namespace std;class Strategy{public:    Strategy(int width):_width(width){}    void format(){        char line[80], word[30];        ifstream inFile(&quot;text.txt&quot;, ios::in);        line[0] = &#39;\0&#39;;        inFile &gt;&gt; word;        strcat(line, word);        while (inFile &gt;&gt; word){            if (strlen(line) + strlen(word) + 1 &gt; _width) {                justufy(line);            }            else{                strcat(line, &quot; &quot;);            }            strcat(line, word);        }        justufy(line);    }protected:    int _width;private:    virtual void justufy(char* line) = 0;};</code></pre><p>LeftStrategy为家族中的一员，实现左对齐。</p><pre><code class="c++">class LeftStragety: public Strategy{public:    LeftStragety(int width): Strategy(width){}private:    void justify(char *line) override{        cout &lt;&lt; line &lt;&lt; endl;        line[0] = &#39;\0&#39;;    }};</code></pre><p>RightStrategy为家族中的一员，实现右对齐。</p><pre><code class="c++">class RightStragety: public Strategy{public:    RightStragety(int width): Strategy(width){}private:    void justify(char *line) override{        char buf[80];        int offset = _width - strlen(line);        memset(buf, &#39; &#39;, 80);        strcpy(&amp;(buf[offset]), line);        cout &lt;&lt; buf &lt;&lt; endl;        line[0] = &#39;\0&#39;;    }};</code></pre><p>CenterStrategy为家族中的一员，实现居中。</p><pre><code class="c++">class CenterStragety: public Strategy{public:    CenterStragety(int width): Strategy(width){}private:    void justify(char *line) override{        char buf[80];        int offset = (_width - strlen(line)) / 2;        memset(buf, &#39; &#39;, 80);        strcpy(&amp;(buf[offset]), line);        cout &lt;&lt; buf &lt;&lt; endl;        line[0] = &#39;\0&#39;;    }};</code></pre><p>以上是整个族系算法。接下来还需要一个类实现算法抽换和执行。</p><p>setStrategy()实现抽换，doit()执行。</p><p>(也可以不构造此类，让用户自己进行算法的抽换)</p><pre><code class="c++">class Test{public:    enum StrategyType{        Undefined, Left, Right, Center    };    Test(): _strategy(NULL){}    void setStrategy(int type, int width){        if (_strategy != NULL) {            delete _strategy;        }        switch (type) {            case Left:                _strategy = new LeftStragety(width);                break;            case Right:                _strategy = new RightStragety(width);                    break;            case Center:                _strategy = new CenterStragety(width);                    break;            default:                break;        }    }    void doit(){        _strategy-&gt;format();    }private:Strategy* _strategy;    int a;};</code></pre><p>main()函数</p><pre><code class="c++">int main(int argc, const char * argv[]) {    Test _test;    int type, width;    cout &lt;&lt; &quot;Exit(0) Left(1) Right(2) Center(3): &quot;;    cin &gt;&gt; type;    while (type) {        cout &lt;&lt; &quot;width: &quot;;        cin &gt;&gt; width;        _test.setStrategy(type, width);        _test.doit();        cout &lt;&lt; &quot;Exit(0) Left(1) Right(2) Center(3): &quot;;        cin &gt;&gt; type;    }}</code></pre><p>若之后要加入在家族中加入一个新成员（这里指新的格式），只要在Test类的setStrategy（抽换算法）中添加一个新的选择即可。</p></li></ul></li></ul><h1 id="Observer-publish-subscribe"><a href="#Observer-publish-subscribe" class="headerlink" title="Observer/publish-subscribe"></a>Observer/publish-subscribe</h1><ul><li><p><strong>定义</strong></p><p>在objects之间定义“一对多”的依存关系，当一个object发生改变时，其他依存于它的objects们也会被通知并更新。</p></li><li><p><strong>示例</strong></p><ul><li><p>类图</p><p><img src="https://i.natfrp.com/6cafc22f5ae227f56111092958fdae27.png" srcset="/img/loading.gif" alt="Observer"></p></li><li><p>java代码</p><p><strong>java中已经封装了Observer和Observable以供使用，这里为了进一步掌握这个设计模式，重新实现了Observer设计模式。</strong></p><p>首先定一个Observe接口和Subject主体用于通知全部订阅了的观察者（对应标准库中的Observable）</p><pre><code class="java">interface Observer{    void update(int value);}class Subject{    int m_value;    List&lt;Observer&gt; m_views;    Subject(){        m_views = new ArrayList&lt;&gt;();    }    public void addObserver(Observer observe){        m_views.add(observe);    }    private void notifyChanges(){        for (Observer observe: m_views){            observe.update(m_value);        }    }    public void set_value(int value){        m_value = value;        notifyChanges();    }}</code></pre><p>实现了继承Observer的两个观察者</p><pre><code class="java">class DivObserve implements Observer{    private int m_div;    DivObserve(int div){        m_div = div;    }    @Override    public void update(int value) {        System.out.println(value+&quot; div &quot;+m_div+&quot; = &quot;+(value / m_div));    }}class ModObserve implements Observer{    private int m_mod;    ModObserve(int mod){        m_mod = mod;    }    @Override    public void update(int value) {        System.out.println(value+&quot; mod &quot;+m_mod+&quot; = &quot;+(value % m_mod));    }}</code></pre><p>main()函数在创建新观察者后，调用addObserver()函数订阅（依赖）subject主体。</p><pre><code class="java">public class Main {    public static void main(String[] args) {        Subject subject = new Subject();        DivObserve div1 = new DivObserve(4);        DivObserve div2 = new DivObserve(3);        ModObserve mod1 = new ModObserve(3);        subject.addObserver(div1);        subject.addObserver(div2);        subject.addObserver(mod1);        subject.set_value(14);    }}</code></pre></li><li><p>输出</p><pre>14 div 4 = 314 div 3 = 414 mod 3 = 2</pre></li></ul></li></ul><h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><p>参考：<a href="https://sourcemaking.com/design_patterns" target="_blank" rel="noopener">Design Patterns</a></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回顾html</title>
    <link href="undefined2019/10/08/%E5%9B%9E%E9%A1%BEhtml/"/>
    <url>2019/10/08/%E5%9B%9E%E9%A1%BEhtml/</url>
    
    <content type="html"><![CDATA[<p>对html语言进行了回顾和再次学习。</p><h2 id="html样式"><a href="#html样式" class="headerlink" title="html样式"></a>html样式</h2><p>一些标签和属性都用html中的style属性所代替了。</p><h4 id="被抛弃的标签和属性"><a href="#被抛弃的标签和属性" class="headerlink" title="被抛弃的标签和属性"></a>被抛弃的标签和属性</h4><table><thead><tr><th>标签/属性</th><th>描述</th></tr></thead><tbody><tr><td>&lt;center&gt;</td><td>定义居中的内容</td></tr><tr><td>&lt;font&gt;和&lt;basefont&gt;</td><td>定义HTML字体</td></tr><tr><td>&lt;s&gt;和&lt;strike&gt;(使用&lt;del&gt;代替)</td><td>定义删除线文本</td></tr><tr><td>&lt;u&gt;(使用样式&lt;ins&gt;代替)</td><td>定义下划线文本</td></tr><tr><td>align</td><td>定义文本对齐方式</td></tr><tr><td>bgcolor/color</td><td>定义背景/文本颜色</td></tr></tbody></table><h2 id="html折行"><a href="#html折行" class="headerlink" title="html折行"></a>html折行</h2><p>使用&lt;br /&gt;标签:</p><pre><code class="html">&lt;p&gt;This is&lt;br /&gt;a para&lt;br /&gt;graph with line breaks&lt;/p&gt;</code></pre><h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><table><thead><tr><th>标签</th><th>效果</th></tr></thead><tbody><tr><td>&lt;p&gt;</td><td>正常</td></tr><tr><td>&lt;big&gt;</td><td><big>大号</big></td></tr><tr><td>&lt;em&gt;</td><td><em>着重</em></td></tr><tr><td>&lt;i&gt;</td><td><i>斜体</i></td></tr><tr><td>&lt;small&gt;</td><td><small>小号</small></td></tr><tr><td>&lt;b&gt;</td><td><b>粗体</b></td></tr><tr><td>&lt;strong&gt;</td><td><strong>加强语气</strong></td></tr><tr><td>&lt;sub&gt;</td><td>正常<sub>下标</sub></td></tr><tr><td>&lt;sup&gt;</td><td>正常<sup>上标</sup></td></tr><tr><td>&lt;ins&gt;</td><td><ins>插入</ins></td></tr><tr><td>&lt;del&gt;</td><td><del>删除</del></td></tr></tbody></table><h4 id="“计算机输出“标签"><a href="#“计算机输出“标签" class="headerlink" title="“计算机输出“标签"></a>“计算机输出“标签</h4><table><thead><tr><th>标签</th><th>效果</th></tr></thead><tbody><tr><td>&lt;code&gt;</td><td><code>prinf()</code></td></tr><tr><td>&lt;kbd&gt;</td><td><kbd>space</kbd></td></tr><tr><td>&lt;pre&gt;</td><td><pre>预格式文本</pre></td></tr><tr><td>&lt;var&gt;</td><td><var>变量</var></td></tr><tr><td>&lt;tt&gt;</td><td><tt>打字机格式</tt></td></tr></tbody></table><p>&lt;code&gt; 元素不保留多余的空格和折行，用&lt;pre&gt;解决。</p><pre><code>&lt;code&gt;&lt;pre&gt;var person = {    firstName:&quot;Bill&quot;,    lastName:&quot;Gates&quot;,    age:50,    eyeColor:&quot;blue&quot;}&lt;/pre&gt;&lt;/code&gt;</code></pre><p>效果：</p><code><pre>var person = {    firstName:"Bill",    lastName:"Gates",    age:50,    eyeColor:"blue"}</pre></code><h4 id="引用和术语定义"><a href="#引用和术语定义" class="headerlink" title="引用和术语定义"></a>引用和术语定义</h4><table><thead><tr><th>标签</th><th>效果</th></tr></thead><tbody><tr><td>&lt;abbr&gt;(缩写)</td><td><abbr title="etcetera">etc.</abbr></td></tr><tr><td>&lt;acronym&gt;(首字母缩写)</td><td><acronym title="World Wide Web">WWW</acronym></td></tr><tr><td>&lt;q&gt;</td><td><q>引用，周围有引号</q></td></tr><tr><td>&lt;bdo&gt;(dir=”rtl”)</td><td><bdo dir="rtl">Reverse</bdo></td></tr><tr><td>&lt;dfn&gt;</td><td><p><dfn title="World Health Organization">WHO</dfn> 成立于 1948 年。</p></td></tr></tbody></table><h2 id="HTML-链接-target-属性"><a href="#HTML-链接-target-属性" class="headerlink" title="HTML 链接 - target 属性"></a>HTML 链接 - target 属性</h2><p>下面的这行会在新窗口打开文档：</p><pre><code>&lt;a href=&quot;http://www.w3school.com.cn/&quot; target=&quot;_blank&quot;&gt;Visit W3School!&lt;/a&gt;</code></pre><h2 id="HTML-链接-name-属性"><a href="#HTML-链接-name-属性" class="headerlink" title="HTML 链接 - name 属性"></a>HTML 链接 - name 属性</h2><p>首先，我们在 HTML 文档中对锚进行命名（创建一个书签）：</p><pre><code>&lt;a name=&quot;tips&quot;&gt;基本的注意事项 - 有用的提示&lt;/a&gt;</code></pre><p>然后，我们在同一个文档中创建指向该锚的链接：</p><pre><code>&lt;a href=&quot;#tips&quot;&gt;有用的提示&lt;/a&gt;</code></pre><p>您也可以在其他页面中创建指向该锚的链接：</p><pre><code>&lt;a href=&quot;http://www.w3school.com.cn/html/html_links.asp#tips&quot;&gt;有用的提示&lt;/a&gt;</code></pre><h2 id="div与span的区别"><a href="#div与span的区别" class="headerlink" title="div与span的区别"></a>div与span的区别</h2><p>div是块级元素，可以用于布局。<br>span是内联元素，多用于为部分文本设置不一样的样式。</p><h2 id="HTML文件路径"><a href="#HTML文件路径" class="headerlink" title="HTML文件路径"></a>HTML文件路径</h2><table><thead><tr><th align="left">路径</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">&lt;img src=”picture.jpg”&gt;</td><td align="left">picture.jpg 位于与当前网页相同的文件夹</td></tr><tr><td align="left">&lt;img src=”images/picture.jpg”&gt;</td><td align="left">picture.jpg 位于当前文件夹的 images 文件夹中</td></tr><tr><td align="left">&lt;img src=”/images/picture.jpg”&gt;</td><td align="left">picture.jpg 当前站点根目录的 images 文件夹中</td></tr><tr><td align="left">&lt;img src=”../picture.jpg”&gt;</td><td align="left">picture.jpg 位于当前文件夹的上一级文件夹中</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>